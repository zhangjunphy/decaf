<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<style type="text/css">
span.lineno { color: white; background: #aaaaaa; border-right: solid white 12px }
span.nottickedoff { background: yellow}
span.istickedoff { background: white }
span.tickonlyfalse { margin: -1px; border: 1px solid #f20913; background: #f20913 }
span.tickonlytrue  { margin: -1px; border: 1px solid #60de51; background: #60de51 }
span.funcount { font-size: small; color: orange; z-index: 2; position: absolute; right: 20 }
span.decl { font-weight: bold }
span.spaces    { background: white }
</style>
</head>
<body>
<pre>
<span class="decl"><span class="nottickedoff">never executed</span> <span class="tickonlytrue">always true</span> <span class="tickonlyfalse">always false</span></span>
</pre>
<pre>
<span class="lineno">    1 </span>-- Semantic -- Decaf semantic checker
<span class="lineno">    2 </span>-- Copyright (C) 2018 Jun Zhang &lt;zhangjunphy[at]gmail[dot]com&gt;
<span class="lineno">    3 </span>--
<span class="lineno">    4 </span>-- This file is a part of decafc.
<span class="lineno">    5 </span>--
<span class="lineno">    6 </span>-- decafc is free software: you can redistribute it and/or modify it under the
<span class="lineno">    7 </span>-- terms of the MIT (X11) License as described in the LICENSE file.
<span class="lineno">    8 </span>--
<span class="lineno">    9 </span>-- decafc is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineno">   10 </span>-- WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
<span class="lineno">   11 </span>-- FOR A PARTICULAR PURPOSE.  See the X11 license for more details.
<span class="lineno">   12 </span>{-# LANGUAGE DataKinds #-}
<span class="lineno">   13 </span>{-# LANGUAGE DuplicateRecordFields #-}
<span class="lineno">   14 </span>{-# LANGUAGE GADTs #-}
<span class="lineno">   15 </span>{-# LANGUAGE GeneralizedNewtypeDeriving #-}
<span class="lineno">   16 </span>{-# LANGUAGE OverloadedLabels #-}
<span class="lineno">   17 </span>{-# LANGUAGE OverloadedStrings #-}
<span class="lineno">   18 </span>
<span class="lineno">   19 </span>module Semantic
<span class="lineno">   20 </span>  ( runSemanticAnalysis,
<span class="lineno">   21 </span>    SymbolTable (..),
<span class="lineno">   22 </span>    ScopeID,
<span class="lineno">   23 </span>    BlockType (..),
<span class="lineno">   24 </span>    lookupLocalVariableFromST,
<span class="lineno">   25 </span>    lookupLocalMethodFromST,
<span class="lineno">   26 </span>  )
<span class="lineno">   27 </span>where
<span class="lineno">   28 </span>
<span class="lineno">   29 </span>import AST
<span class="lineno">   30 </span>import Constants
<span class="lineno">   31 </span>import Control.Applicative ((&lt;|&gt;))
<span class="lineno">   32 </span>import Control.Lens (view)
<span class="lineno">   33 </span>import Control.Monad.Except
<span class="lineno">   34 </span>import Control.Monad.State
<span class="lineno">   35 </span>import Control.Monad.Writer.Lazy
<span class="lineno">   36 </span>import Data.Char (ord)
<span class="lineno">   37 </span>import Data.Functor ((&lt;&amp;&gt;))
<span class="lineno">   38 </span>import Data.Generics.Labels ()
<span class="lineno">   39 </span>import Data.Int (Int64)
<span class="lineno">   40 </span>import Data.List (find)
<span class="lineno">   41 </span>import Data.Map (Map)
<span class="lineno">   42 </span>import qualified Data.Map as Map
<span class="lineno">   43 </span>import Data.Maybe (isJust, isNothing)
<span class="lineno">   44 </span>import Data.Text (Text)
<span class="lineno">   45 </span>import qualified Data.Text as T
<span class="lineno">   46 </span>import qualified Data.Text.Read as T
<span class="lineno">   47 </span>import Formatting
<span class="lineno">   48 </span>import qualified Parser as P
<span class="lineno">   49 </span>import qualified SourceLoc as SL
<span class="lineno">   50 </span>
<span class="lineno">   51 </span>---------------------------------------
<span class="lineno">   52 </span>-- Semantic informations and errors
<span class="lineno">   53 </span>---------------------------------------
<span class="lineno">   54 </span>
<span class="lineno">   55 </span>-- semantic errors
<span class="lineno">   56 </span>-- these errors are produced during semantic analysis,
<span class="lineno">   57 </span>-- we try to detect as many as we can in a single pass
<span class="lineno">   58 </span>data SemanticError = SemanticError SL.Range Text
<span class="lineno">   59 </span>
<span class="lineno">   60 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show SemanticError</span></span></span></span> where
<span class="lineno">   61 </span>  <span class="decl"><span class="nottickedoff">show (SemanticError range msg) = formatToString (shown % &quot;: &quot; % stext) range msg</span></span>
<span class="lineno">   62 </span>
<span class="lineno">   63 </span>-- exceptions during semantic analysis
<span class="lineno">   64 </span>-- difference from SemanticError:
<span class="lineno">   65 </span>-- whenever an exception is raised, the analysis procedure will be aborted.
<span class="lineno">   66 </span>data SemanticException = SemanticException SL.Range Text
<span class="lineno">   67 </span>
<span class="lineno">   68 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show SemanticException</span></span></span></span> where
<span class="lineno">   69 </span>  <span class="decl"><span class="nottickedoff">show (SemanticException range msg) = formatToString (shown % &quot; &quot; % stext) range msg</span></span>
<span class="lineno">   70 </span>
<span class="lineno">   71 </span>data BlockType = RootBlock | IfBlock | ForBlock | WhileBlock | MethodBlock
<span class="lineno">   72 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Eq</span></span></span></span>)
<span class="lineno">   73 </span>
<span class="lineno">   74 </span>-- symbol table definitions
<span class="lineno">   75 </span>data SymbolTable = SymbolTable
<span class="lineno">   76 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">scopeID</span></span></span> :: ScopeID,
<span class="lineno">   77 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">parent</span></span></span> :: Maybe SymbolTable,
<span class="lineno">   78 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">importSymbols</span></span></span> :: Maybe (Map Name ImportDecl),
<span class="lineno">   79 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">variableSymbols</span></span></span> :: Map Name FieldDecl,
<span class="lineno">   80 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">methodSymbols</span></span></span> :: Maybe (Map Name MethodDecl),
<span class="lineno">   81 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">blockType</span></span></span> :: BlockType,
<span class="lineno">   82 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">methodSig</span></span></span> :: Maybe MethodSig
<span class="lineno">   83 </span>  }
<span class="lineno">   84 </span>
<span class="lineno">   85 </span>instance <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show SymbolTable</span></span></span></span> where
<span class="lineno">   86 </span>  <span class="decl"><span class="nottickedoff">show (SymbolTable sid p imports variables methods tpe _) =</span>
<span class="lineno">   87 </span><span class="spaces">    </span><span class="nottickedoff">formatToString</span>
<span class="lineno">   88 </span><span class="spaces">      </span><span class="nottickedoff">(&quot;SymbolTable {scopeID=&quot; % int % &quot;, parent=&quot; % shown % &quot;, imports=&quot; % shown % &quot;, variables=&quot; % shown % &quot;, methods=&quot; % shown % &quot;, tpe=&quot; % shown)</span>
<span class="lineno">   89 </span><span class="spaces">      </span><span class="nottickedoff">sid</span>
<span class="lineno">   90 </span><span class="spaces">      </span><span class="nottickedoff">(scopeID &lt;$&gt; p)</span>
<span class="lineno">   91 </span><span class="spaces">      </span><span class="nottickedoff">(show imports)</span>
<span class="lineno">   92 </span><span class="spaces">      </span><span class="nottickedoff">(show variables)</span>
<span class="lineno">   93 </span><span class="spaces">      </span><span class="nottickedoff">(show methods)</span>
<span class="lineno">   94 </span><span class="spaces">      </span><span class="nottickedoff">(show tpe)</span></span>
<span class="lineno">   95 </span>
<span class="lineno">   96 </span>data SemanticState = SemanticState
<span class="lineno">   97 </span>  { <span class="istickedoff"><span class="decl"><span class="istickedoff">nextScopeID</span></span></span> :: ScopeID,
<span class="lineno">   98 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">currentScopeID</span></span></span> :: ScopeID,
<span class="lineno">   99 </span>    <span class="istickedoff"><span class="decl"><span class="istickedoff">symbolTables</span></span></span> :: Map ScopeID SymbolTable,
<span class="lineno">  100 </span>    <span class="nottickedoff"><span class="decl"><span class="nottickedoff">currentRange</span></span></span> :: SL.Range
<span class="lineno">  101 </span>  }
<span class="lineno">  102 </span>  deriving (<span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Show</span></span></span></span></span></span>)
<span class="lineno">  103 </span>
<span class="lineno">  104 </span>-- Monad used for semantic analysis
<span class="lineno">  105 </span>-- Symbol tables are built for every scope, and stored in SemanticState.
<span class="lineno">  106 </span>-- Semantic errors encountered are recorded by the writer monad (WriterT [SemanticError]).
<span class="lineno">  107 </span>-- If a serious problem happened such that the analysis has to be aborted, a SemanticException
<span class="lineno">  108 </span>-- is thrown.
<span class="lineno">  109 </span>newtype Semantic a = Semantic {<span class="istickedoff"><span class="decl"><span class="istickedoff">runSemantic</span></span></span> :: ExceptT SemanticException (WriterT [SemanticError] (State SemanticState)) a}
<span class="lineno">  110 </span>  deriving (<span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff">Functor</span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">Applicative</span></span></span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">Monad</span></span></span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadError SemanticException</span></span></span></span>, <span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff"><span class="decl"><span class="nottickedoff">MonadWriter [SemanticError]</span></span></span></span></span></span></span></span>, <span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff"><span class="decl"><span class="istickedoff">MonadState SemanticState</span></span></span></span></span></span>)
<span class="lineno">  111 </span>
<span class="lineno">  112 </span>runSemanticAnalysis :: P.Program -&gt; Either String (ASTRoot, [SemanticError], Map ScopeID SymbolTable)
<span class="lineno">  113 </span><span class="decl"><span class="istickedoff">runSemanticAnalysis p =</span>
<span class="lineno">  114 </span><span class="spaces">  </span><span class="istickedoff">let ir = irgenRoot p</span>
<span class="lineno">  115 </span><span class="spaces">      </span><span class="istickedoff">((except, errors), state) = (runState $ runWriterT $ runExceptT $ runSemantic ir) initialSemanticState</span>
<span class="lineno">  116 </span><span class="spaces">   </span><span class="istickedoff">in case except of</span>
<span class="lineno">  117 </span><span class="spaces">        </span><span class="istickedoff">Left except -&gt; <span class="nottickedoff">Left $ show except</span></span>
<span class="lineno">  118 </span><span class="spaces">        </span><span class="istickedoff">Right a -&gt; Right (a, <span class="nottickedoff">errors</span>, <span class="nottickedoff">symbolTables state</span>)</span></span>
<span class="lineno">  119 </span>
<span class="lineno">  120 </span>initialSemanticState :: SemanticState
<span class="lineno">  121 </span><span class="decl"><span class="istickedoff">initialSemanticState =</span>
<span class="lineno">  122 </span><span class="spaces">  </span><span class="istickedoff">let globalST =</span>
<span class="lineno">  123 </span><span class="spaces">        </span><span class="istickedoff">SymbolTable</span>
<span class="lineno">  124 </span><span class="spaces">          </span><span class="istickedoff">{ scopeID = globalScopeID,</span>
<span class="lineno">  125 </span><span class="spaces">            </span><span class="istickedoff">parent = <span class="nottickedoff">Nothing</span>,</span>
<span class="lineno">  126 </span><span class="spaces">            </span><span class="istickedoff">importSymbols = Just Map.empty,</span>
<span class="lineno">  127 </span><span class="spaces">            </span><span class="istickedoff">variableSymbols = Map.empty,</span>
<span class="lineno">  128 </span><span class="spaces">            </span><span class="istickedoff">methodSymbols = Just Map.empty,</span>
<span class="lineno">  129 </span><span class="spaces">            </span><span class="istickedoff">blockType = RootBlock,</span>
<span class="lineno">  130 </span><span class="spaces">            </span><span class="istickedoff">methodSig = <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  131 </span><span class="spaces">          </span><span class="istickedoff">}</span>
<span class="lineno">  132 </span><span class="spaces">   </span><span class="istickedoff">in SemanticState</span>
<span class="lineno">  133 </span><span class="spaces">        </span><span class="istickedoff">{ nextScopeID = globalScopeID + 1,</span>
<span class="lineno">  134 </span><span class="spaces">          </span><span class="istickedoff">currentScopeID = globalScopeID,</span>
<span class="lineno">  135 </span><span class="spaces">          </span><span class="istickedoff">symbolTables = Map.fromList [(globalScopeID, globalST)],</span>
<span class="lineno">  136 </span><span class="spaces">          </span><span class="istickedoff">currentRange = <span class="nottickedoff">SL.Range (SL.Posn 0 0 0) (SL.Posn 0 0 0)</span></span>
<span class="lineno">  137 </span><span class="spaces">        </span><span class="istickedoff">}</span></span>
<span class="lineno">  138 </span>
<span class="lineno">  139 </span>updateCurrentRange :: SL.Range -&gt; Semantic ()
<span class="lineno">  140 </span><span class="decl"><span class="istickedoff">updateCurrentRange range = modify (\s -&gt; s {currentRange = <span class="nottickedoff">range</span>})</span></span>
<span class="lineno">  141 </span>
<span class="lineno">  142 </span>getCurrentRange :: Semantic SL.Range
<span class="lineno">  143 </span><span class="decl"><span class="nottickedoff">getCurrentRange = gets currentRange</span></span>
<span class="lineno">  144 </span>
<span class="lineno">  145 </span>-- throw exception or store errors
<span class="lineno">  146 </span>throwSemanticException :: Text -&gt; Semantic a
<span class="lineno">  147 </span><span class="decl"><span class="nottickedoff">throwSemanticException msg = do</span>
<span class="lineno">  148 </span><span class="spaces">  </span><span class="nottickedoff">range &lt;- getCurrentRange</span>
<span class="lineno">  149 </span><span class="spaces">  </span><span class="nottickedoff">throwError $ SemanticException range msg</span></span>
<span class="lineno">  150 </span>
<span class="lineno">  151 </span>addSemanticError :: Text -&gt; Semantic ()
<span class="lineno">  152 </span><span class="decl"><span class="nottickedoff">addSemanticError msg = do</span>
<span class="lineno">  153 </span><span class="spaces">  </span><span class="nottickedoff">range &lt;- getCurrentRange</span>
<span class="lineno">  154 </span><span class="spaces">  </span><span class="nottickedoff">tell [SemanticError range msg]</span></span>
<span class="lineno">  155 </span>
<span class="lineno">  156 </span>-- find symbol table for global scope
<span class="lineno">  157 </span>getGlobalSymbolTable' :: Semantic SymbolTable
<span class="lineno">  158 </span><span class="decl"><span class="istickedoff">getGlobalSymbolTable' = do</span>
<span class="lineno">  159 </span><span class="spaces">  </span><span class="istickedoff">state &lt;- get</span>
<span class="lineno">  160 </span><span class="spaces">  </span><span class="istickedoff">case Map.lookup globalScopeID $ symbolTables state of</span>
<span class="lineno">  161 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwSemanticException &quot;No global symbol table found!&quot;</span></span>
<span class="lineno">  162 </span><span class="spaces">    </span><span class="istickedoff">Just t -&gt; return t</span></span>
<span class="lineno">  163 </span>
<span class="lineno">  164 </span>-- find symbol table for current scope
<span class="lineno">  165 </span>getSymbolTable :: Semantic (Maybe SymbolTable)
<span class="lineno">  166 </span><span class="decl"><span class="istickedoff">getSymbolTable = do</span>
<span class="lineno">  167 </span><span class="spaces">  </span><span class="istickedoff">state &lt;- get</span>
<span class="lineno">  168 </span><span class="spaces">  </span><span class="istickedoff">let id = currentScopeID state</span>
<span class="lineno">  169 </span><span class="spaces">  </span><span class="istickedoff">return $ Map.lookup id $ symbolTables state</span></span>
<span class="lineno">  170 </span>
<span class="lineno">  171 </span>getCurrentScopeID :: Semantic Int
<span class="lineno">  172 </span><span class="decl"><span class="istickedoff">getCurrentScopeID = gets <span class="nottickedoff">currentScopeID</span></span></span>
<span class="lineno">  173 </span>
<span class="lineno">  174 </span>-- find symbol table for current scope
<span class="lineno">  175 </span>-- will throw SemanticException if nothing is found
<span class="lineno">  176 </span>getSymbolTable' :: Semantic SymbolTable
<span class="lineno">  177 </span><span class="decl"><span class="istickedoff">getSymbolTable' = do</span>
<span class="lineno">  178 </span><span class="spaces">  </span><span class="istickedoff">scopeID &lt;- getCurrentScopeID</span>
<span class="lineno">  179 </span><span class="spaces">  </span><span class="istickedoff">t &lt;- getSymbolTable</span>
<span class="lineno">  180 </span><span class="spaces">  </span><span class="istickedoff">case t of</span>
<span class="lineno">  181 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  182 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">throwSemanticException $ sformat (&quot;No symble table found for current scope &quot; % int) scopeID</span></span>
<span class="lineno">  183 </span><span class="spaces">    </span><span class="istickedoff">Just table -&gt; return table</span></span>
<span class="lineno">  184 </span>
<span class="lineno">  185 </span>getLocalVariables' :: Semantic (Map Name FieldDecl)
<span class="lineno">  186 </span><span class="decl"><span class="nottickedoff">getLocalVariables' = do</span>
<span class="lineno">  187 </span><span class="spaces">  </span><span class="nottickedoff">variableSymbols &lt;$&gt; getSymbolTable'</span></span>
<span class="lineno">  188 </span>
<span class="lineno">  189 </span>getLocalImports' :: Semantic (Map Name ImportDecl)
<span class="lineno">  190 </span><span class="decl"><span class="nottickedoff">getLocalImports' = do</span>
<span class="lineno">  191 </span><span class="spaces">  </span><span class="nottickedoff">localST &lt;- getSymbolTable'</span>
<span class="lineno">  192 </span><span class="spaces">  </span><span class="nottickedoff">case importSymbols localST of</span>
<span class="lineno">  193 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; throwSemanticException $ sformat (&quot;No import table for scope &quot; % int) $ scopeID localST</span>
<span class="lineno">  194 </span><span class="spaces">    </span><span class="nottickedoff">Just t -&gt; return t</span></span>
<span class="lineno">  195 </span>
<span class="lineno">  196 </span>getLocalMethods' :: Semantic (Map Name MethodDecl)
<span class="lineno">  197 </span><span class="decl"><span class="istickedoff">getLocalMethods' = do</span>
<span class="lineno">  198 </span><span class="spaces">  </span><span class="istickedoff">localST &lt;- getSymbolTable'</span>
<span class="lineno">  199 </span><span class="spaces">  </span><span class="istickedoff">case methodSymbols localST of</span>
<span class="lineno">  200 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwSemanticException $ sformat (&quot;No method table for scope &quot; % int) $ scopeID localST</span></span>
<span class="lineno">  201 </span><span class="spaces">    </span><span class="istickedoff">Just t -&gt; return t</span></span>
<span class="lineno">  202 </span>
<span class="lineno">  203 </span>updateSymbolTable :: SymbolTable -&gt; Semantic ()
<span class="lineno">  204 </span><span class="decl"><span class="istickedoff">updateSymbolTable t = do</span>
<span class="lineno">  205 </span><span class="spaces">  </span><span class="istickedoff">state &lt;- get</span>
<span class="lineno">  206 </span><span class="spaces">  </span><span class="istickedoff">-- ensure the symbol table is present, otherwise throw an exception</span>
<span class="lineno">  207 </span><span class="spaces">  </span><span class="istickedoff">getSymbolTable'</span>
<span class="lineno">  208 </span><span class="spaces">  </span><span class="istickedoff">put $ state {symbolTables = Map.insert (currentScopeID state) t (symbolTables state)}</span></span>
<span class="lineno">  209 </span>
<span class="lineno">  210 </span>getMethodSignature :: Semantic (Maybe MethodSig)
<span class="lineno">  211 </span><span class="decl"><span class="istickedoff">getMethodSignature = do lookup &lt;$&gt; getSymbolTable'</span>
<span class="lineno">  212 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  213 </span><span class="spaces">    </span><span class="istickedoff">lookup :: SymbolTable -&gt; Maybe MethodSig</span>
<span class="lineno">  214 </span><span class="spaces">    </span><span class="istickedoff">lookup SymbolTable {blockType = RootBlock} = Nothing</span>
<span class="lineno">  215 </span><span class="spaces">    </span><span class="istickedoff">lookup SymbolTable {blockType = MethodBlock, methodSig = sig} = sig</span>
<span class="lineno">  216 </span><span class="spaces">    </span><span class="istickedoff">lookup SymbolTable {parent = Just p} = <span class="nottickedoff">lookup p</span></span></span>
<span class="lineno">  217 </span>
<span class="lineno">  218 </span>getMethodSignature' :: Semantic MethodSig
<span class="lineno">  219 </span><span class="decl"><span class="nottickedoff">getMethodSignature' = do</span>
<span class="lineno">  220 </span><span class="spaces">  </span><span class="nottickedoff">sig &lt;- getMethodSignature</span>
<span class="lineno">  221 </span><span class="spaces">  </span><span class="nottickedoff">case sig of</span>
<span class="lineno">  222 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; throwSemanticException &quot;Cannot find signature for current function!&quot;</span>
<span class="lineno">  223 </span><span class="spaces">    </span><span class="nottickedoff">Just s -&gt; return s</span></span>
<span class="lineno">  224 </span>
<span class="lineno">  225 </span>enterScope :: BlockType -&gt; Maybe MethodSig -&gt; Semantic ScopeID
<span class="lineno">  226 </span><span class="decl"><span class="istickedoff">enterScope blockType sig = do</span>
<span class="lineno">  227 </span><span class="spaces">  </span><span class="istickedoff">state &lt;- get</span>
<span class="lineno">  228 </span><span class="spaces">  </span><span class="istickedoff">parentST &lt;- getSymbolTable</span>
<span class="lineno">  229 </span><span class="spaces">  </span><span class="istickedoff">let nextID = nextScopeID state</span>
<span class="lineno">  230 </span><span class="spaces">      </span><span class="istickedoff">localST =</span>
<span class="lineno">  231 </span><span class="spaces">        </span><span class="istickedoff">SymbolTable</span>
<span class="lineno">  232 </span><span class="spaces">          </span><span class="istickedoff">{ scopeID = <span class="nottickedoff">nextID</span>,</span>
<span class="lineno">  233 </span><span class="spaces">            </span><span class="istickedoff">parent = parentST,</span>
<span class="lineno">  234 </span><span class="spaces">            </span><span class="istickedoff">variableSymbols = Map.empty,</span>
<span class="lineno">  235 </span><span class="spaces">            </span><span class="istickedoff">importSymbols = <span class="nottickedoff">Nothing</span>,</span>
<span class="lineno">  236 </span><span class="spaces">            </span><span class="istickedoff">methodSymbols = <span class="nottickedoff">Nothing</span>,</span>
<span class="lineno">  237 </span><span class="spaces">            </span><span class="istickedoff">blockType = blockType,</span>
<span class="lineno">  238 </span><span class="spaces">            </span><span class="istickedoff">methodSig = sig</span>
<span class="lineno">  239 </span><span class="spaces">          </span><span class="istickedoff">}</span>
<span class="lineno">  240 </span><span class="spaces">  </span><span class="istickedoff">put $</span>
<span class="lineno">  241 </span><span class="spaces">    </span><span class="istickedoff">state</span>
<span class="lineno">  242 </span><span class="spaces">      </span><span class="istickedoff">{ nextScopeID = <span class="nottickedoff">nextID + 1</span>,</span>
<span class="lineno">  243 </span><span class="spaces">        </span><span class="istickedoff">currentScopeID = nextID,</span>
<span class="lineno">  244 </span><span class="spaces">        </span><span class="istickedoff">symbolTables = Map.insert nextID localST $ symbolTables state</span>
<span class="lineno">  245 </span><span class="spaces">      </span><span class="istickedoff">}</span>
<span class="lineno">  246 </span><span class="spaces">  </span><span class="istickedoff">return <span class="nottickedoff">nextID</span></span></span>
<span class="lineno">  247 </span>
<span class="lineno">  248 </span>exitScope :: Semantic ()
<span class="lineno">  249 </span><span class="decl"><span class="istickedoff">exitScope = do</span>
<span class="lineno">  250 </span><span class="spaces">  </span><span class="istickedoff">state &lt;- get</span>
<span class="lineno">  251 </span><span class="spaces">  </span><span class="istickedoff">localST &lt;- getSymbolTable</span>
<span class="lineno">  252 </span><span class="spaces">  </span><span class="istickedoff">case localST of</span>
<span class="lineno">  253 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  254 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">throwSemanticException $</span></span>
<span class="lineno">  255 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">sformat (&quot;No symbol table is associated with scope(&quot; % int % &quot;)!&quot;) $</span></span>
<span class="lineno">  256 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">currentScopeID state</span></span>
<span class="lineno">  257 </span><span class="spaces">    </span><span class="istickedoff">Just table -&gt;</span>
<span class="lineno">  258 </span><span class="spaces">      </span><span class="istickedoff">case parent table of</span>
<span class="lineno">  259 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt;</span>
<span class="lineno">  260 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">throwSemanticException &quot;Cannot exit root scope!&quot;</span></span>
<span class="lineno">  261 </span><span class="spaces">        </span><span class="istickedoff">Just p -&gt;</span>
<span class="lineno">  262 </span><span class="spaces">          </span><span class="istickedoff">put $ state {currentScopeID = scopeID p}</span></span>
<span class="lineno">  263 </span>
<span class="lineno">  264 </span>----------------------------------------------------------------------
<span class="lineno">  265 </span>-- Convert the parser tree into an AST
<span class="lineno">  266 </span>-- Generate symbol tables at the same time.
<span class="lineno">  267 </span>-- Also detects semantic errors.
<span class="lineno">  268 </span>----------------------------------------------------------------------
<span class="lineno">  269 </span>
<span class="lineno">  270 </span>{-
<span class="lineno">  271 </span>Semantic rules to be checked, this will be referenced as Semantic[n]in comments below.
<span class="lineno">  272 </span>1. Identifier duplication.
<span class="lineno">  273 </span>2. Identifier should be declared before used.
<span class="lineno">  274 </span>3. Check for method &quot;main&quot;. Also check the parameters and return type.
<span class="lineno">  275 </span>4. Array length should be greater than 0.
<span class="lineno">  276 </span>5. Method call has matching type and number of arguments.
<span class="lineno">  277 </span>6. Method must return something if used in expressions.
<span class="lineno">  278 </span>7. String literals and array variables may not be used as args to non-import methods.
<span class="lineno">  279 </span>8. Method declared without a return type shall return nothing.
<span class="lineno">  280 </span>9. Method return type should match declared type.
<span class="lineno">  281 </span>10. id used as location should name a variable or parameter.
<span class="lineno">  282 </span>11. Method should be declared or imported before used.
<span class="lineno">  283 </span>12. Array location must refer to an array varaible, also the index expression must be of type int.
<span class="lineno">  284 </span>13. Argument of len operator must be an array.
<span class="lineno">  285 </span>14. The expression of 'if' and 'when', as well as the second expression of 'for' must have type 'bool'.
<span class="lineno">  286 </span>15. In a conditional expression (?:):
<span class="lineno">  287 </span>    The first expression must have type bool.
<span class="lineno">  288 </span>    The alternatives must have the same type.
<span class="lineno">  289 </span>16. The operands of the unary negative operator, arithmetic ops and relational ops must have type int.
<span class="lineno">  290 </span>17. The operands of equal ops must have the same type.
<span class="lineno">  291 </span>18. The operands of the logical not op and conditional op must have type bool.
<span class="lineno">  292 </span>19. The location and expression in an assignment must have the same type.
<span class="lineno">  293 </span>20. The location and expression in an incremental assignment must have type int.
<span class="lineno">  294 </span>21. All break and continue statment must be within a for or while loop.
<span class="lineno">  295 </span>22. All int literals must be in the range of -9223372036854775808 ≤ x ≤ 9223372036854775807
<span class="lineno">  296 </span>(64 bits).
<span class="lineno">  297 </span>-}
<span class="lineno">  298 </span>
<span class="lineno">  299 </span>{-
<span class="lineno">  300 </span>  Helper functions to manipulate symbol tables.
<span class="lineno">  301 </span>-}
<span class="lineno">  302 </span>
<span class="lineno">  303 </span>{- Varaible lookup. -}
<span class="lineno">  304 </span>
<span class="lineno">  305 </span>lookupLocalVariableFromST :: Name -&gt; SymbolTable -&gt; Maybe MethodSig -&gt; Maybe (Either Argument FieldDecl)
<span class="lineno">  306 </span><span class="decl"><span class="istickedoff">lookupLocalVariableFromST name st sig =</span>
<span class="lineno">  307 </span><span class="spaces">  </span><span class="istickedoff">let f = lookupLocalFieldDecl name st</span>
<span class="lineno">  308 </span><span class="spaces">      </span><span class="istickedoff">a = lookupArgument <span class="nottickedoff">name</span> <span class="nottickedoff">st</span></span>
<span class="lineno">  309 </span><span class="spaces">   </span><span class="istickedoff">in (Right &lt;$&gt; f) &lt;|&gt; (<span class="nottickedoff">Left</span> &lt;$&gt; a)</span>
<span class="lineno">  310 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  311 </span><span class="spaces">    </span><span class="istickedoff">lookupLocalFieldDecl name st = Map.lookup name $ variableSymbols st</span>
<span class="lineno">  312 </span><span class="spaces">    </span><span class="istickedoff">lookupArgument name st = do</span>
<span class="lineno">  313 </span><span class="spaces">      </span><span class="istickedoff">(MethodSig _ _ args) &lt;- sig</span>
<span class="lineno">  314 </span><span class="spaces">      </span><span class="istickedoff">SL.LocatedAt _ arg &lt;- find <span class="nottickedoff">(\(SL.LocatedAt _ (Argument nm _)) -&gt; nm == name)</span> args</span>
<span class="lineno">  315 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return arg</span></span></span>
<span class="lineno">  316 </span>
<span class="lineno">  317 </span>lookupVariable :: Name -&gt; Semantic (Maybe (Either Argument FieldDecl))
<span class="lineno">  318 </span><span class="decl"><span class="istickedoff">lookupVariable name = do</span>
<span class="lineno">  319 </span><span class="spaces">  </span><span class="istickedoff">st &lt;- getSymbolTable</span>
<span class="lineno">  320 </span><span class="spaces">  </span><span class="istickedoff">sig &lt;- getMethodSignature</span>
<span class="lineno">  321 </span><span class="spaces">  </span><span class="istickedoff">return $ st &gt;&gt;= lookup name sig</span>
<span class="lineno">  322 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  323 </span><span class="spaces">    </span><span class="istickedoff">lookup name sig st' =</span>
<span class="lineno">  324 </span><span class="spaces">      </span><span class="istickedoff">(lookupLocalVariableFromST name st' sig)</span>
<span class="lineno">  325 </span><span class="spaces">        </span><span class="istickedoff">&lt;|&gt; (parent st' &gt;&gt;= lookup name <span class="nottickedoff">sig</span>)</span></span>
<span class="lineno">  326 </span>
<span class="lineno">  327 </span>lookupVariable' :: Name -&gt; Semantic (Either Argument FieldDecl)
<span class="lineno">  328 </span><span class="decl"><span class="istickedoff">lookupVariable' name = do</span>
<span class="lineno">  329 </span><span class="spaces">  </span><span class="istickedoff">v &lt;- lookupVariable name</span>
<span class="lineno">  330 </span><span class="spaces">  </span><span class="istickedoff">case v of</span>
<span class="lineno">  331 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">throwSemanticException $ sformat (&quot;Varaible &quot; % stext % &quot; not defined&quot;) name</span></span>
<span class="lineno">  332 </span><span class="spaces">    </span><span class="istickedoff">Just v -&gt; return v</span></span>
<span class="lineno">  333 </span>
<span class="lineno">  334 </span>{- Method lookup. -}
<span class="lineno">  335 </span>
<span class="lineno">  336 </span>lookupLocalMethodFromST :: Name -&gt; SymbolTable -&gt; Maybe (Either ImportDecl MethodDecl)
<span class="lineno">  337 </span><span class="decl"><span class="istickedoff">lookupLocalMethodFromST name table =</span>
<span class="lineno">  338 </span><span class="spaces">  </span><span class="istickedoff">let method = do</span>
<span class="lineno">  339 </span><span class="spaces">        </span><span class="istickedoff">methodTable &lt;- methodSymbols table</span>
<span class="lineno">  340 </span><span class="spaces">        </span><span class="istickedoff">Map.lookup name methodTable</span>
<span class="lineno">  341 </span><span class="spaces">      </span><span class="istickedoff">import' = do</span>
<span class="lineno">  342 </span><span class="spaces">        </span><span class="istickedoff">importTable &lt;- importSymbols table</span>
<span class="lineno">  343 </span><span class="spaces">        </span><span class="istickedoff">Map.lookup name importTable</span>
<span class="lineno">  344 </span><span class="spaces">   </span><span class="istickedoff">in (<span class="nottickedoff">Right</span> &lt;$&gt; method) &lt;|&gt; (<span class="nottickedoff">Left</span> &lt;$&gt; import')</span></span>
<span class="lineno">  345 </span>
<span class="lineno">  346 </span>lookupMethod :: Name -&gt; Semantic (Maybe (Either ImportDecl MethodDecl))
<span class="lineno">  347 </span><span class="decl"><span class="nottickedoff">lookupMethod name = do</span>
<span class="lineno">  348 </span><span class="spaces">  </span><span class="nottickedoff">lookup name &lt;$&gt; getSymbolTable'</span>
<span class="lineno">  349 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  350 </span><span class="spaces">    </span><span class="nottickedoff">lookup name table = (lookupLocalMethodFromST name table) &lt;|&gt; (parent table &gt;&gt;= lookup name)</span></span>
<span class="lineno">  351 </span>
<span class="lineno">  352 </span>lookupMethod' :: Name -&gt; Semantic (Either ImportDecl MethodDecl)
<span class="lineno">  353 </span><span class="decl"><span class="nottickedoff">lookupMethod' name = do</span>
<span class="lineno">  354 </span><span class="spaces">  </span><span class="nottickedoff">m &lt;- lookupMethod name</span>
<span class="lineno">  355 </span><span class="spaces">  </span><span class="nottickedoff">case m of</span>
<span class="lineno">  356 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; throwSemanticException $ sformat (&quot;Method &quot; % stext % &quot; not found&quot;) name</span>
<span class="lineno">  357 </span><span class="spaces">    </span><span class="nottickedoff">Just m' -&gt; return m'</span></span>
<span class="lineno">  358 </span>
<span class="lineno">  359 </span>{- Add variables and methods -}
<span class="lineno">  360 </span>
<span class="lineno">  361 </span>addVariableDef :: FieldDecl -&gt; Semantic ()
<span class="lineno">  362 </span><span class="decl"><span class="istickedoff">addVariableDef def = do</span>
<span class="lineno">  363 </span><span class="spaces">  </span><span class="istickedoff">localST &lt;- getSymbolTable'</span>
<span class="lineno">  364 </span><span class="spaces">  </span><span class="istickedoff">sig &lt;- getMethodSignature</span>
<span class="lineno">  365 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[1]</span>
<span class="lineno">  366 </span><span class="spaces">  </span><span class="istickedoff">let nm = view #name def</span>
<span class="lineno">  367 </span><span class="spaces">  </span><span class="istickedoff">when</span>
<span class="lineno">  368 </span><span class="spaces">    </span><span class="istickedoff">(isJust (lookupLocalVariableFromST nm localST sig))</span>
<span class="lineno">  369 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError $ sformat (&quot;duplicate definition for variable &quot; % stext) nm)</span></span>
<span class="lineno">  370 </span><span class="spaces">  </span><span class="istickedoff">let variableSymbols' = Map.insert (view #name (def :: FieldDecl)) def (variableSymbols localST)</span>
<span class="lineno">  371 </span><span class="spaces">      </span><span class="istickedoff">newST = localST {variableSymbols = variableSymbols'}</span>
<span class="lineno">  372 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[4]</span>
<span class="lineno">  373 </span><span class="spaces">  </span><span class="istickedoff">case def of</span>
<span class="lineno">  374 </span><span class="spaces">    </span><span class="istickedoff">(FieldDecl _ (ArrayType _ sz))</span>
<span class="lineno">  375 </span><span class="spaces">      </span><span class="istickedoff">| <span class="tickonlyfalse">sz &lt; 0</span> -&gt;</span>
<span class="lineno">  376 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">addSemanticError $ sformat (&quot;Invalid size of array &quot; % stext) nm</span></span>
<span class="lineno">  377 </span><span class="spaces">    </span><span class="istickedoff">_ -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  378 </span><span class="spaces">  </span><span class="istickedoff">updateSymbolTable newST</span></span>
<span class="lineno">  379 </span>
<span class="lineno">  380 </span>addImportDef :: ImportDecl -&gt; Semantic ()
<span class="lineno">  381 </span><span class="decl"><span class="nottickedoff">addImportDef def = do</span>
<span class="lineno">  382 </span><span class="spaces">  </span><span class="nottickedoff">localST &lt;- getSymbolTable'</span>
<span class="lineno">  383 </span><span class="spaces">  </span><span class="nottickedoff">importTable &lt;- getLocalImports'</span>
<span class="lineno">  384 </span><span class="spaces">  </span><span class="nottickedoff">-- Semantic[1]</span>
<span class="lineno">  385 </span><span class="spaces">  </span><span class="nottickedoff">let nm = view #name def</span>
<span class="lineno">  386 </span><span class="spaces">  </span><span class="nottickedoff">when</span>
<span class="lineno">  387 </span><span class="spaces">    </span><span class="nottickedoff">(isJust $ Map.lookup (view #name (def :: ImportDecl)) importTable)</span>
<span class="lineno">  388 </span><span class="spaces">    </span><span class="nottickedoff">(addSemanticError $ sformat (&quot;duplicate import &quot; % stext) nm)</span>
<span class="lineno">  389 </span><span class="spaces">  </span><span class="nottickedoff">let importSymbols' = Map.insert (view #name (def :: ImportDecl)) def importTable</span>
<span class="lineno">  390 </span><span class="spaces">      </span><span class="nottickedoff">newST = localST {importSymbols = Just importSymbols'}</span>
<span class="lineno">  391 </span><span class="spaces">  </span><span class="nottickedoff">updateSymbolTable newST</span></span>
<span class="lineno">  392 </span>
<span class="lineno">  393 </span>addMethodDef :: MethodDecl -&gt; Semantic ()
<span class="lineno">  394 </span><span class="decl"><span class="istickedoff">addMethodDef def = do</span>
<span class="lineno">  395 </span><span class="spaces">  </span><span class="istickedoff">localST &lt;- getSymbolTable'</span>
<span class="lineno">  396 </span><span class="spaces">  </span><span class="istickedoff">methodTable &lt;- getLocalMethods'</span>
<span class="lineno">  397 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[1]</span>
<span class="lineno">  398 </span><span class="spaces">  </span><span class="istickedoff">let nm = view #name (view #sig def)</span>
<span class="lineno">  399 </span><span class="spaces">  </span><span class="istickedoff">when</span>
<span class="lineno">  400 </span><span class="spaces">    </span><span class="istickedoff">(isJust $ lookupLocalMethodFromST nm localST)</span>
<span class="lineno">  401 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError $ sformat (&quot;duplicate definition for method &quot; % stext) nm)</span></span>
<span class="lineno">  402 </span><span class="spaces">  </span><span class="istickedoff">let methodSymbols' = Map.insert nm def methodTable</span>
<span class="lineno">  403 </span><span class="spaces">      </span><span class="istickedoff">newST = localST {methodSymbols = Just methodSymbols'}</span>
<span class="lineno">  404 </span><span class="spaces">  </span><span class="istickedoff">updateSymbolTable newST</span></span>
<span class="lineno">  405 </span>
<span class="lineno">  406 </span>{-
<span class="lineno">  407 </span>  Helper methods to do semantic checks.
<span class="lineno">  408 </span>-}
<span class="lineno">  409 </span>
<span class="lineno">  410 </span>-- Semantic[8] and Semantic[9]
<span class="lineno">  411 </span>checkReturnType :: Maybe (Typed Expr) -&gt; Semantic ()
<span class="lineno">  412 </span><span class="decl"><span class="nottickedoff">checkReturnType Nothing = do</span>
<span class="lineno">  413 </span><span class="spaces">  </span><span class="nottickedoff">(MethodSig method tpe _) &lt;- getMethodSignature'</span>
<span class="lineno">  414 </span><span class="spaces">  </span><span class="nottickedoff">case tpe of</span>
<span class="lineno">  415 </span><span class="spaces">    </span><span class="nottickedoff">Just t -&gt; addSemanticError $ sformat (&quot;Method &quot; % stext % &quot; expects return type of &quot; % shown % &quot;!&quot;) method t</span>
<span class="lineno">  416 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; return ()</span>
<span class="lineno">  417 </span><span class="spaces"></span><span class="nottickedoff">checkReturnType (Just (Typed _ tpe')) = do</span>
<span class="lineno">  418 </span><span class="spaces">  </span><span class="nottickedoff">(MethodSig method tpe _) &lt;- getMethodSignature'</span>
<span class="lineno">  419 </span><span class="spaces">  </span><span class="nottickedoff">case tpe of</span>
<span class="lineno">  420 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; addSemanticError $ sformat (&quot;Method &quot; % stext % &quot; expects no return value!&quot;) method</span>
<span class="lineno">  421 </span><span class="spaces">    </span><span class="nottickedoff">t</span>
<span class="lineno">  422 </span><span class="spaces">      </span><span class="nottickedoff">| t /= tpe -&gt;</span>
<span class="lineno">  423 </span><span class="spaces">          </span><span class="nottickedoff">addSemanticError $</span>
<span class="lineno">  424 </span><span class="spaces">            </span><span class="nottickedoff">sformat</span>
<span class="lineno">  425 </span><span class="spaces">              </span><span class="nottickedoff">(&quot;Method &quot; % stext % &quot; expects return type of &quot; % shown % &quot;, but got &quot; % shown % &quot; instead.&quot;)</span>
<span class="lineno">  426 </span><span class="spaces">              </span><span class="nottickedoff">method</span>
<span class="lineno">  427 </span><span class="spaces">              </span><span class="nottickedoff">tpe</span>
<span class="lineno">  428 </span><span class="spaces">              </span><span class="nottickedoff">tpe'</span>
<span class="lineno">  429 </span><span class="spaces">    </span><span class="nottickedoff">_ -&gt; return ()</span></span>
<span class="lineno">  430 </span>
<span class="lineno">  431 </span>-- | Check if content of lit is a valid int64.
<span class="lineno">  432 </span>-- lit should be striped of whitespace from both ends and contains only
<span class="lineno">  433 </span>-- numeric characters or the minus sign '-'.
<span class="lineno">  434 </span>-- -9223372036854775808 ≤ x ≤ 9223372036854775807
<span class="lineno">  435 </span>-- checks Semantic[22].
<span class="lineno">  436 </span>checkInt64Literal :: Text -&gt; Semantic Int64
<span class="lineno">  437 </span><span class="decl"><span class="istickedoff">checkInt64Literal lit = do</span>
<span class="lineno">  438 </span><span class="spaces">  </span><span class="istickedoff">when (T.null lit) $</span>
<span class="lineno">  439 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">throwSemanticException &quot;Cannot parse int literal from an empty token!&quot;</span></span>
<span class="lineno">  440 </span><span class="spaces">  </span><span class="istickedoff">let <span class="nottickedoff">isNegative = (T.head lit) == '-'</span></span>
<span class="lineno">  441 </span><span class="spaces">  </span><span class="istickedoff">-- unless</span>
<span class="lineno">  442 </span><span class="spaces">  </span><span class="istickedoff">--   ( (isNegative &amp;&amp; (T.drop 1 lit) &lt;= &quot;9223372036854775808&quot;)</span>
<span class="lineno">  443 </span><span class="spaces">  </span><span class="istickedoff">--       || (not isNegative &amp;&amp; lit &lt;= &quot;9223372036854775807&quot;)</span>
<span class="lineno">  444 </span><span class="spaces">  </span><span class="istickedoff">--   )</span>
<span class="lineno">  445 </span><span class="spaces">  </span><span class="istickedoff">--   throwSemanticException</span>
<span class="lineno">  446 </span><span class="spaces">  </span><span class="istickedoff">--   $ printf &quot;Int literal %s is out of bound&quot; lit</span>
<span class="lineno">  447 </span><span class="spaces">  </span><span class="istickedoff">case T.decimal lit of</span>
<span class="lineno">  448 </span><span class="spaces">    </span><span class="istickedoff">Right (n, _) -&gt; return n</span>
<span class="lineno">  449 </span><span class="spaces">    </span><span class="istickedoff">Left msg -&gt; <span class="nottickedoff">throwSemanticException $ sformat (&quot;cannot parse int literal &quot; % string) msg</span></span></span>
<span class="lineno">  450 </span>
<span class="lineno">  451 </span>checkBoolLiteral :: Text -&gt; Semantic Bool
<span class="lineno">  452 </span><span class="decl"><span class="istickedoff">checkBoolLiteral lit</span>
<span class="lineno">  453 </span><span class="spaces">  </span><span class="istickedoff">| <span class="tickonlytrue">lit == &quot;true&quot;</span> = return <span class="nottickedoff">True</span></span>
<span class="lineno">  454 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">lit == &quot;flase&quot;</span> = <span class="nottickedoff">return False</span></span>
<span class="lineno">  455 </span><span class="spaces">  </span><span class="istickedoff">| <span class="nottickedoff">otherwise</span> = <span class="nottickedoff">do</span></span>
<span class="lineno">  456 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">addSemanticError $ sformat (&quot;error parsing bool literal from string &quot; % stext) lit</span></span>
<span class="lineno">  457 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return True</span></span></span>
<span class="lineno">  458 </span>
<span class="lineno">  459 </span>checkCharLiteral :: Text -&gt; Semantic Char
<span class="lineno">  460 </span><span class="decl"><span class="nottickedoff">checkCharLiteral lit = do</span>
<span class="lineno">  461 </span><span class="spaces">  </span><span class="nottickedoff">when</span>
<span class="lineno">  462 </span><span class="spaces">    </span><span class="nottickedoff">(T.length lit &gt; 1 || T.null lit)</span>
<span class="lineno">  463 </span><span class="spaces">    </span><span class="nottickedoff">(throwSemanticException $ sformat (&quot;cannot parse char literal from string &quot; % stext) lit)</span>
<span class="lineno">  464 </span><span class="spaces">  </span><span class="nottickedoff">return $ T.head lit</span></span>
<span class="lineno">  465 </span>
<span class="lineno">  466 </span>isInsideLoop :: Semantic Bool
<span class="lineno">  467 </span><span class="decl"><span class="nottickedoff">isInsideLoop = do</span>
<span class="lineno">  468 </span><span class="spaces">  </span><span class="nottickedoff">lookup &lt;$&gt; getSymbolTable'</span>
<span class="lineno">  469 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  470 </span><span class="spaces">    </span><span class="nottickedoff">lookup SymbolTable {blockType = ForBlock} = True</span>
<span class="lineno">  471 </span><span class="spaces">    </span><span class="nottickedoff">lookup SymbolTable {blockType = WhileBlock} = True</span>
<span class="lineno">  472 </span><span class="spaces">    </span><span class="nottickedoff">lookup SymbolTable {blockType = IfBlock, parent = Nothing} = False</span>
<span class="lineno">  473 </span><span class="spaces">    </span><span class="nottickedoff">lookup SymbolTable {blockType = IfBlock, parent = Just p} = lookup p</span></span>
<span class="lineno">  474 </span>
<span class="lineno">  475 </span>{-
<span class="lineno">  476 </span>  Methods to generate ir piece by piece.
<span class="lineno">  477 </span>-}
<span class="lineno">  478 </span>
<span class="lineno">  479 </span>irgenRoot :: P.Program -&gt; Semantic ASTRoot
<span class="lineno">  480 </span><span class="decl"><span class="istickedoff">irgenRoot (P.Program imports fields methods) = do</span>
<span class="lineno">  481 </span><span class="spaces">  </span><span class="istickedoff">imports' &lt;- irgenImports imports</span>
<span class="lineno">  482 </span><span class="spaces">  </span><span class="istickedoff">variables' &lt;- irgenFieldDecls fields</span>
<span class="lineno">  483 </span><span class="spaces">  </span><span class="istickedoff">methods' &lt;- irgenMethodDecls methods</span>
<span class="lineno">  484 </span><span class="spaces"></span><span class="istickedoff"></span>
<span class="lineno">  485 </span><span class="spaces">  </span><span class="istickedoff">-- check method &quot;main&quot;</span>
<span class="lineno">  486 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[3]</span>
<span class="lineno">  487 </span><span class="spaces">  </span><span class="istickedoff">globalTable &lt;- getGlobalSymbolTable'</span>
<span class="lineno">  488 </span><span class="spaces">  </span><span class="istickedoff">let main = do</span>
<span class="lineno">  489 </span><span class="spaces">        </span><span class="istickedoff">methodSyms &lt;- methodSymbols globalTable</span>
<span class="lineno">  490 </span><span class="spaces">        </span><span class="istickedoff">Map.lookup mainMethodName methodSyms</span>
<span class="lineno">  491 </span><span class="spaces">  </span><span class="istickedoff">mainDecl &lt;- checkMainExist main</span>
<span class="lineno">  492 </span><span class="spaces">  </span><span class="istickedoff">case mainDecl &gt;&gt;= Just . view #sig of</span>
<span class="lineno">  493 </span><span class="spaces">    </span><span class="istickedoff">Just (MethodSig _ retType args) -&gt; do</span>
<span class="lineno">  494 </span><span class="spaces">      </span><span class="istickedoff">checkMainRetType retType</span>
<span class="lineno">  495 </span><span class="spaces">      </span><span class="istickedoff">checkMainArgsType args</span>
<span class="lineno">  496 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">return ()</span></span>
<span class="lineno">  497 </span><span class="spaces">  </span><span class="istickedoff">return $ ASTRoot <span class="nottickedoff">imports'</span> <span class="nottickedoff">variables'</span> methods'</span>
<span class="lineno">  498 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  499 </span><span class="spaces">    </span><span class="istickedoff">checkMainExist main =</span>
<span class="lineno">  500 </span><span class="spaces">      </span><span class="istickedoff">case main of</span>
<span class="lineno">  501 </span><span class="spaces">        </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  502 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">addSemanticError &quot;Method \&quot;main\&quot; not found!&quot;</span></span>
<span class="lineno">  503 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">return Nothing</span></span>
<span class="lineno">  504 </span><span class="spaces">        </span><span class="istickedoff">Just decl -&gt; return $ Just decl</span>
<span class="lineno">  505 </span><span class="spaces">    </span><span class="istickedoff">checkMainRetType tpe = case tpe of</span>
<span class="lineno">  506 </span><span class="spaces">      </span><span class="istickedoff">Nothing -&gt; return <span class="nottickedoff">()</span></span>
<span class="lineno">  507 </span><span class="spaces">      </span><span class="istickedoff">Just tpe -&gt;</span>
<span class="lineno">  508 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">addSemanticError $</span></span>
<span class="lineno">  509 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">sformat</span></span>
<span class="lineno">  510 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">(&quot;Method \&quot;main\&quot; should have return type of void, got &quot; % shown % &quot; instead.&quot;)</span></span>
<span class="lineno">  511 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">tpe</span></span>
<span class="lineno">  512 </span><span class="spaces">    </span><span class="istickedoff">checkMainArgsType args =</span>
<span class="lineno">  513 </span><span class="spaces">      </span><span class="istickedoff">unless</span>
<span class="lineno">  514 </span><span class="spaces">        </span><span class="istickedoff">(null args)</span>
<span class="lineno">  515 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Method \&quot;main\&quot; should have no argument.&quot;)</span></span></span>
<span class="lineno">  516 </span>
<span class="lineno">  517 </span>irgenType :: P.Type -&gt; Type
<span class="lineno">  518 </span><span class="decl"><span class="istickedoff">irgenType P.IntType = IntType</span>
<span class="lineno">  519 </span><span class="spaces"></span><span class="istickedoff">irgenType P.BoolType = BoolType</span></span>
<span class="lineno">  520 </span>
<span class="lineno">  521 </span>irgenImports :: [SL.Located P.ImportDecl] -&gt; Semantic [SL.Located ImportDecl]
<span class="lineno">  522 </span><span class="decl"><span class="istickedoff">irgenImports [] = return <span class="nottickedoff">[]</span></span>
<span class="lineno">  523 </span><span class="spaces"></span><span class="istickedoff">irgenImports ((SL.LocatedAt range (P.ImportDecl id)) : rest) = <span class="nottickedoff">do</span></span>
<span class="lineno">  524 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">let importSymbol = ImportDecl id</span></span>
<span class="lineno">  525 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">addImportDef importSymbol</span></span>
<span class="lineno">  526 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- TODO: This kind of recursions potentially lead to stack overflows.</span></span>
<span class="lineno">  527 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- For now it should do the job. Will try to fix in the future.</span></span>
<span class="lineno">  528 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">rest' &lt;- irgenImports rest</span></span>
<span class="lineno">  529 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range importSymbol : rest'</span></span></span>
<span class="lineno">  530 </span>
<span class="lineno">  531 </span>irgenFieldDecls :: [SL.Located P.FieldDecl] -&gt; Semantic [SL.Located FieldDecl]
<span class="lineno">  532 </span><span class="decl"><span class="istickedoff">irgenFieldDecls [] = return <span class="nottickedoff">[]</span></span>
<span class="lineno">  533 </span><span class="spaces"></span><span class="istickedoff">irgenFieldDecls ((SL.LocatedAt pos decl) : rest) = do</span>
<span class="lineno">  534 </span><span class="spaces">  </span><span class="istickedoff">fields &lt;- sequence $ convertFieldDecl decl</span>
<span class="lineno">  535 </span><span class="spaces">  </span><span class="istickedoff">vars &lt;- addVariables fields</span>
<span class="lineno">  536 </span><span class="spaces">  </span><span class="istickedoff">rest' &lt;- irgenFieldDecls rest</span>
<span class="lineno">  537 </span><span class="spaces">  </span><span class="istickedoff">return <span class="nottickedoff">(vars ++ rest')</span></span>
<span class="lineno">  538 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  539 </span><span class="spaces">    </span><span class="istickedoff">convertFieldDecl (P.FieldDecl tpe elems) =</span>
<span class="lineno">  540 </span><span class="spaces">      </span><span class="istickedoff">elems &lt;&amp;&gt; \e -&gt; case e of</span>
<span class="lineno">  541 </span><span class="spaces">        </span><span class="istickedoff">(SL.LocatedAt range (P.ScalarField id)) -&gt; do</span>
<span class="lineno">  542 </span><span class="spaces">          </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">range</span></span>
<span class="lineno">  543 </span><span class="spaces">          </span><span class="istickedoff">return $ SL.LocatedAt <span class="nottickedoff">pos</span> $ FieldDecl id (irgenType tpe)</span>
<span class="lineno">  544 </span><span class="spaces">        </span><span class="istickedoff">(SL.LocatedAt range (P.VectorField id size)) -&gt; do</span>
<span class="lineno">  545 </span><span class="spaces">          </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">pos</span></span>
<span class="lineno">  546 </span><span class="spaces">          </span><span class="istickedoff">sz &lt;- checkInt64Literal size</span>
<span class="lineno">  547 </span><span class="spaces">          </span><span class="istickedoff">return $ SL.LocatedAt <span class="nottickedoff">pos</span> $ FieldDecl id (ArrayType (irgenType tpe) sz)</span>
<span class="lineno">  548 </span><span class="spaces">    </span><span class="istickedoff">addVariables [] = return <span class="nottickedoff">[]</span></span>
<span class="lineno">  549 </span><span class="spaces">    </span><span class="istickedoff">addVariables (v : vs) = do</span>
<span class="lineno">  550 </span><span class="spaces">      </span><span class="istickedoff">addVariableDef $ SL.unLocate v</span>
<span class="lineno">  551 </span><span class="spaces">      </span><span class="istickedoff">vs' &lt;- addVariables vs</span>
<span class="lineno">  552 </span><span class="spaces">      </span><span class="istickedoff">return <span class="nottickedoff">(v : vs')</span></span></span>
<span class="lineno">  553 </span>
<span class="lineno">  554 </span>irgenMethodDecls :: [SL.Located P.MethodDecl] -&gt; Semantic [SL.Located MethodDecl]
<span class="lineno">  555 </span><span class="decl"><span class="istickedoff">irgenMethodDecls [] = return <span class="nottickedoff">[]</span></span>
<span class="lineno">  556 </span><span class="spaces"></span><span class="istickedoff">irgenMethodDecls ((SL.LocatedAt range decl) : rest) = do</span>
<span class="lineno">  557 </span><span class="spaces">  </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">range</span></span>
<span class="lineno">  558 </span><span class="spaces">  </span><span class="istickedoff">method &lt;- convertMethodDecl decl</span>
<span class="lineno">  559 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[8] and Semantic[9]</span>
<span class="lineno">  560 </span><span class="spaces">  </span><span class="istickedoff">-- checkMethod method</span>
<span class="lineno">  561 </span><span class="spaces">  </span><span class="istickedoff">addMethodDef method</span>
<span class="lineno">  562 </span><span class="spaces">  </span><span class="istickedoff">rest' &lt;- irgenMethodDecls rest</span>
<span class="lineno">  563 </span><span class="spaces">  </span><span class="istickedoff">return (SL.LocatedAt <span class="nottickedoff">range</span> method : <span class="nottickedoff">rest'</span>)</span>
<span class="lineno">  564 </span><span class="spaces">  </span><span class="istickedoff">where</span>
<span class="lineno">  565 </span><span class="spaces">    </span><span class="istickedoff">convertMethodDecl (P.MethodDecl id returnType arguments block) = do</span>
<span class="lineno">  566 </span><span class="spaces">      </span><span class="istickedoff">let sig = MethodSig id (<span class="nottickedoff">irgenType</span> &lt;$&gt; returnType) args</span>
<span class="lineno">  567 </span><span class="spaces">      </span><span class="istickedoff">block &lt;- irgenBlock MethodBlock (Just sig) block</span>
<span class="lineno">  568 </span><span class="spaces">      </span><span class="istickedoff">return $ MethodDecl sig block</span>
<span class="lineno">  569 </span><span class="spaces">      </span><span class="istickedoff">where</span>
<span class="lineno">  570 </span><span class="spaces">        </span><span class="istickedoff">args =</span>
<span class="lineno">  571 </span><span class="spaces">          </span><span class="istickedoff">arguments &lt;&amp;&gt; <span class="nottickedoff">\(SL.LocatedAt range (P.Argument id tpe)) -&gt;</span></span>
<span class="lineno">  572 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">SL.LocatedAt range $ Argument id (irgenType tpe)</span></span></span>
<span class="lineno">  573 </span>
<span class="lineno">  574 </span>irgenBlock :: BlockType -&gt; Maybe MethodSig -&gt; P.Block -&gt; Semantic Block
<span class="lineno">  575 </span><span class="decl"><span class="istickedoff">irgenBlock blockType sig (P.Block fieldDecls statements) = do</span>
<span class="lineno">  576 </span><span class="spaces">  </span><span class="istickedoff">nextID &lt;- enterScope blockType sig</span>
<span class="lineno">  577 </span><span class="spaces">  </span><span class="istickedoff">fields &lt;- irgenFieldDecls fieldDecls</span>
<span class="lineno">  578 </span><span class="spaces">  </span><span class="istickedoff">stmts &lt;- irgenStatements statements</span>
<span class="lineno">  579 </span><span class="spaces">  </span><span class="istickedoff">let block = Block <span class="nottickedoff">fields</span> stmts <span class="nottickedoff">nextID</span></span>
<span class="lineno">  580 </span><span class="spaces">  </span><span class="istickedoff">exitScope</span>
<span class="lineno">  581 </span><span class="spaces">  </span><span class="istickedoff">return block</span></span>
<span class="lineno">  582 </span>
<span class="lineno">  583 </span>irgenLocation :: P.Location -&gt; Semantic (Typed Location)
<span class="lineno">  584 </span><span class="decl"><span class="istickedoff">irgenLocation (P.ScalarLocation id) = do</span>
<span class="lineno">  585 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[10] (checked in lookupVariable')</span>
<span class="lineno">  586 </span><span class="spaces">  </span><span class="istickedoff">def &lt;- lookupVariable' id</span>
<span class="lineno">  587 </span><span class="spaces">  </span><span class="istickedoff">let tpe = either <span class="nottickedoff">(\(Argument _ tpe') -&gt; tpe')</span> (\(FieldDecl _ tpe') -&gt; tpe') def</span>
<span class="lineno">  588 </span><span class="spaces">  </span><span class="istickedoff">let sz =</span>
<span class="lineno">  589 </span><span class="spaces">        </span><span class="istickedoff">either</span>
<span class="lineno">  590 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">(const Nothing)</span></span>
<span class="lineno">  591 </span><span class="spaces">          </span><span class="istickedoff">( \(FieldDecl _ tpe) -&gt; case tpe of</span>
<span class="lineno">  592 </span><span class="spaces">              </span><span class="istickedoff">(ArrayType _ sz') -&gt; <span class="nottickedoff">Just sz'</span></span>
<span class="lineno">  593 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; Nothing</span>
<span class="lineno">  594 </span><span class="spaces">          </span><span class="istickedoff">)</span>
<span class="lineno">  595 </span><span class="spaces">          </span><span class="istickedoff">def</span>
<span class="lineno">  596 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[12]</span>
<span class="lineno">  597 </span><span class="spaces">  </span><span class="istickedoff">case sz of</span>
<span class="lineno">  598 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; return $ Typed <span class="nottickedoff">(Location id Nothing def)</span> tpe</span>
<span class="lineno">  599 </span><span class="spaces">    </span><span class="istickedoff">Just v -&gt; <span class="nottickedoff">return $ Typed (Location id Nothing def) (ArrayType tpe v)</span></span>
<span class="lineno">  600 </span><span class="spaces"></span><span class="istickedoff">irgenLocation (P.VectorLocation id expr) = do</span>
<span class="lineno">  601 </span><span class="spaces">  </span><span class="istickedoff">(SL.LocatedAt _ (Typed expr' indexTpe)) &lt;- irgenExpr expr</span>
<span class="lineno">  602 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[10] (checked in lookupVariable')</span>
<span class="lineno">  603 </span><span class="spaces">  </span><span class="istickedoff">def &lt;- lookupVariable' id</span>
<span class="lineno">  604 </span><span class="spaces">  </span><span class="istickedoff">let tpe = either <span class="nottickedoff">(\(Argument _ tpe') -&gt; tpe')</span> (\(FieldDecl _ tpe') -&gt; tpe') def</span>
<span class="lineno">  605 </span><span class="spaces">  </span><span class="istickedoff">let sz =</span>
<span class="lineno">  606 </span><span class="spaces">        </span><span class="istickedoff">either</span>
<span class="lineno">  607 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">(const Nothing)</span></span>
<span class="lineno">  608 </span><span class="spaces">          </span><span class="istickedoff">( \(FieldDecl _ tpe) -&gt; case tpe of</span>
<span class="lineno">  609 </span><span class="spaces">              </span><span class="istickedoff">(ArrayType _ sz') -&gt; Just <span class="nottickedoff">sz'</span></span>
<span class="lineno">  610 </span><span class="spaces">              </span><span class="istickedoff">_ -&gt; <span class="nottickedoff">Nothing</span></span>
<span class="lineno">  611 </span><span class="spaces">          </span><span class="istickedoff">)</span>
<span class="lineno">  612 </span><span class="spaces">          </span><span class="istickedoff">def</span>
<span class="lineno">  613 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[12]</span>
<span class="lineno">  614 </span><span class="spaces">  </span><span class="istickedoff">when (indexTpe /= IntType) <span class="nottickedoff">(addSemanticError &quot;Index must be of int type!&quot;)</span></span>
<span class="lineno">  615 </span><span class="spaces">  </span><span class="istickedoff">case sz of</span>
<span class="lineno">  616 </span><span class="spaces">    </span><span class="istickedoff">Nothing -&gt; <span class="nottickedoff">do</span></span>
<span class="lineno">  617 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">addSemanticError $</span></span>
<span class="lineno">  618 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">sformat (&quot;Cannot access index of scalar variable &quot; % stext % &quot;.&quot;) id</span></span>
<span class="lineno">  619 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">return $ Typed (Location id Nothing def) tpe</span></span>
<span class="lineno">  620 </span><span class="spaces">    </span><span class="istickedoff">Just _ -&gt; return $ Typed <span class="nottickedoff">(Location id (Just expr') def)</span> tpe</span></span>
<span class="lineno">  621 </span>
<span class="lineno">  622 </span>checkAssignType :: Type -&gt; Type -&gt; Bool
<span class="lineno">  623 </span><span class="decl"><span class="istickedoff">checkAssignType (ArrayType tpe _) exprType = tpe == exprType</span>
<span class="lineno">  624 </span><span class="spaces"></span><span class="istickedoff">checkAssignType locType exprType = locType == exprType</span></span>
<span class="lineno">  625 </span>
<span class="lineno">  626 </span>irgenAssign :: P.Location -&gt; P.AssignExpr -&gt; Semantic Assignment
<span class="lineno">  627 </span><span class="decl"><span class="istickedoff">irgenAssign loc (P.AssignExpr op expr) = do</span>
<span class="lineno">  628 </span><span class="spaces">  </span><span class="istickedoff">loc'@(Typed _ tpe) &lt;- irgenLocation loc</span>
<span class="lineno">  629 </span><span class="spaces">  </span><span class="istickedoff">expr'@(SL.LocatedAt _ (Typed _ tpe')) &lt;- irgenExpr expr</span>
<span class="lineno">  630 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[19]</span>
<span class="lineno">  631 </span><span class="spaces">  </span><span class="istickedoff">when</span>
<span class="lineno">  632 </span><span class="spaces">    </span><span class="istickedoff">(not $ checkAssignType tpe tpe')</span>
<span class="lineno">  633 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError $ sformat (&quot;Assign statement has different types: &quot; % shown % &quot; and &quot; % shown % &quot;&quot;) tpe tpe')</span></span>
<span class="lineno">  634 </span><span class="spaces">  </span><span class="istickedoff">let op' = parseAssignOp op</span>
<span class="lineno">  635 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[20]</span>
<span class="lineno">  636 </span><span class="spaces">  </span><span class="istickedoff">when</span>
<span class="lineno">  637 </span><span class="spaces">    </span><span class="istickedoff">((op' == IncAssign || op' == DecAssign) &amp;&amp; <span class="nottickedoff">(tpe /= IntType)</span>)</span>
<span class="lineno">  638 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Inc or dec assign only works with int type!&quot;)</span></span>
<span class="lineno">  639 </span><span class="spaces">  </span><span class="istickedoff">return $ Assignment <span class="nottickedoff">loc'</span> <span class="nottickedoff">op'</span> (Just expr')</span>
<span class="lineno">  640 </span><span class="spaces"></span><span class="istickedoff">irgenAssign loc (P.IncrementExpr op) = <span class="nottickedoff">do</span></span>
<span class="lineno">  641 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">loc'@(Typed _ tpe) &lt;- irgenLocation loc</span></span>
<span class="lineno">  642 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">let op' = parseAssignOp op</span></span>
<span class="lineno">  643 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[20]</span></span>
<span class="lineno">  644 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when (tpe /= IntType) (addSemanticError &quot;Inc or dec operator only works on int type!&quot;)</span></span>
<span class="lineno">  645 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ Assignment loc' op' Nothing</span></span></span>
<span class="lineno">  646 </span>
<span class="lineno">  647 </span>irgenStatements :: [SL.Located P.Statement] -&gt; Semantic [SL.Located Statement]
<span class="lineno">  648 </span><span class="decl"><span class="istickedoff">irgenStatements [] = return <span class="nottickedoff">[]</span></span>
<span class="lineno">  649 </span><span class="spaces"></span><span class="istickedoff">irgenStatements ((SL.LocatedAt range s) : xs) = do</span>
<span class="lineno">  650 </span><span class="spaces">  </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">range</span></span>
<span class="lineno">  651 </span><span class="spaces">  </span><span class="istickedoff">s' &lt;- irgenStmt s</span>
<span class="lineno">  652 </span><span class="spaces">  </span><span class="istickedoff">xs' &lt;- irgenStatements xs</span>
<span class="lineno">  653 </span><span class="spaces">  </span><span class="istickedoff">return (SL.LocatedAt <span class="nottickedoff">range</span> s' : xs')</span></span>
<span class="lineno">  654 </span>
<span class="lineno">  655 </span>irgenMethod :: P.MethodCall -&gt; Semantic MethodCall
<span class="lineno">  656 </span><span class="decl"><span class="nottickedoff">irgenMethod (P.MethodCall method args') = do</span>
<span class="lineno">  657 </span><span class="spaces">  </span><span class="nottickedoff">-- Semantic[2] and Semantic[11]</span>
<span class="lineno">  658 </span><span class="spaces">  </span><span class="nottickedoff">decl' &lt;- lookupMethod method</span>
<span class="lineno">  659 </span><span class="spaces">  </span><span class="nottickedoff">argsTyped &lt;- traverse irgenImportArg args'</span>
<span class="lineno">  660 </span><span class="spaces">  </span><span class="nottickedoff">case decl' of</span>
<span class="lineno">  661 </span><span class="spaces">    </span><span class="nottickedoff">Nothing -&gt; do</span>
<span class="lineno">  662 </span><span class="spaces">      </span><span class="nottickedoff">currentMethod &lt;- getMethodSignature</span>
<span class="lineno">  663 </span><span class="spaces">      </span><span class="nottickedoff">case currentMethod of</span>
<span class="lineno">  664 </span><span class="spaces">        </span><span class="nottickedoff">-- Recursive method calling itself</span>
<span class="lineno">  665 </span><span class="spaces">        </span><span class="nottickedoff">(Just (MethodSig name _ formal)) | name == method -&gt; do</span>
<span class="lineno">  666 </span><span class="spaces">          </span><span class="nottickedoff">checkCallingSemantics (SL.unLocate &lt;$&gt; formal) (SL.unLocate &lt;$&gt; argsTyped)</span>
<span class="lineno">  667 </span><span class="spaces">          </span><span class="nottickedoff">return $ MethodCall method argsTyped</span>
<span class="lineno">  668 </span><span class="spaces">        </span><span class="nottickedoff">_ -&gt; throwSemanticException $ sformat (&quot;method &quot; % stext % &quot; not declared!&quot;) method</span>
<span class="lineno">  669 </span><span class="spaces">    </span><span class="nottickedoff">Just decl -&gt; case decl of</span>
<span class="lineno">  670 </span><span class="spaces">      </span><span class="nottickedoff">Left _ -&gt; return $ MethodCall method argsTyped</span>
<span class="lineno">  671 </span><span class="spaces">      </span><span class="nottickedoff">Right m -&gt; do</span>
<span class="lineno">  672 </span><span class="spaces">        </span><span class="nottickedoff">let formal = SL.unLocate &lt;$&gt; view #args (view #sig m :: MethodSig)</span>
<span class="lineno">  673 </span><span class="spaces">        </span><span class="nottickedoff">-- Semantic[5] and Semantic[7]</span>
<span class="lineno">  674 </span><span class="spaces">        </span><span class="nottickedoff">checkCallingSemantics formal (SL.unLocate &lt;$&gt; argsTyped)</span>
<span class="lineno">  675 </span><span class="spaces">        </span><span class="nottickedoff">return $ MethodCall method argsTyped</span>
<span class="lineno">  676 </span><span class="spaces">  </span><span class="nottickedoff">where</span>
<span class="lineno">  677 </span><span class="spaces">    </span><span class="nottickedoff">matchPred (Argument _ tpe, Typed _ tpe') = tpe == tpe'</span>
<span class="lineno">  678 </span><span class="spaces">    </span><span class="nottickedoff">argName (Argument name _, _) = name</span>
<span class="lineno">  679 </span><span class="spaces">    </span><span class="nottickedoff">checkArgNum formal args =</span>
<span class="lineno">  680 </span><span class="spaces">      </span><span class="nottickedoff">unless</span>
<span class="lineno">  681 </span><span class="spaces">        </span><span class="nottickedoff">(length formal == length args)</span>
<span class="lineno">  682 </span><span class="spaces">        </span><span class="nottickedoff">( addSemanticError $</span>
<span class="lineno">  683 </span><span class="spaces">            </span><span class="nottickedoff">sformat</span>
<span class="lineno">  684 </span><span class="spaces">              </span><span class="nottickedoff">(&quot;Calling &quot; % stext % &quot; with wrong number of args. Required: &quot; % int % &quot;, supplied: &quot; % int % &quot;.&quot;)</span>
<span class="lineno">  685 </span><span class="spaces">              </span><span class="nottickedoff">method</span>
<span class="lineno">  686 </span><span class="spaces">              </span><span class="nottickedoff">(length formal)</span>
<span class="lineno">  687 </span><span class="spaces">              </span><span class="nottickedoff">(length args)</span>
<span class="lineno">  688 </span><span class="spaces">        </span><span class="nottickedoff">)</span>
<span class="lineno">  689 </span><span class="spaces">    </span><span class="nottickedoff">checkArgType formal args =</span>
<span class="lineno">  690 </span><span class="spaces">      </span><span class="nottickedoff">let mismatch = map argName $ filter (not . matchPred) $ zip formal args</span>
<span class="lineno">  691 </span><span class="spaces">       </span><span class="nottickedoff">in unless</span>
<span class="lineno">  692 </span><span class="spaces">            </span><span class="nottickedoff">(null mismatch)</span>
<span class="lineno">  693 </span><span class="spaces">            </span><span class="nottickedoff">( addSemanticError $</span>
<span class="lineno">  694 </span><span class="spaces">                </span><span class="nottickedoff">sformat</span>
<span class="lineno">  695 </span><span class="spaces">                  </span><span class="nottickedoff">(&quot;Calling &quot; % stext % &quot; with wrong type of args: &quot; % shown)</span>
<span class="lineno">  696 </span><span class="spaces">                  </span><span class="nottickedoff">method</span>
<span class="lineno">  697 </span><span class="spaces">                  </span><span class="nottickedoff">mismatch</span>
<span class="lineno">  698 </span><span class="spaces">            </span><span class="nottickedoff">)</span>
<span class="lineno">  699 </span><span class="spaces">    </span><span class="nottickedoff">arrayOrStringTypePred (Typed _ tpe) = case tpe of</span>
<span class="lineno">  700 </span><span class="spaces">      </span><span class="nottickedoff">ArrayType _ _ -&gt; True</span>
<span class="lineno">  701 </span><span class="spaces">      </span><span class="nottickedoff">StringType -&gt; True</span>
<span class="lineno">  702 </span><span class="spaces">      </span><span class="nottickedoff">_ -&gt; False</span>
<span class="lineno">  703 </span><span class="spaces">    </span><span class="nottickedoff">checkForArrayArg args =</span>
<span class="lineno">  704 </span><span class="spaces">      </span><span class="nottickedoff">let arrayArgs = map (view #ele) $ filter arrayOrStringTypePred args</span>
<span class="lineno">  705 </span><span class="spaces">       </span><span class="nottickedoff">in unless</span>
<span class="lineno">  706 </span><span class="spaces">            </span><span class="nottickedoff">(null arrayArgs)</span>
<span class="lineno">  707 </span><span class="spaces">            </span><span class="nottickedoff">( addSemanticError $</span>
<span class="lineno">  708 </span><span class="spaces">                </span><span class="nottickedoff">sformat</span>
<span class="lineno">  709 </span><span class="spaces">                  </span><span class="nottickedoff">(&quot;Argument of array or string type can not be used for method &quot; % stext)</span>
<span class="lineno">  710 </span><span class="spaces">                  </span><span class="nottickedoff">method</span>
<span class="lineno">  711 </span><span class="spaces">            </span><span class="nottickedoff">)</span>
<span class="lineno">  712 </span><span class="spaces">    </span><span class="nottickedoff">checkCallingSemantics formal args = do</span>
<span class="lineno">  713 </span><span class="spaces">      </span><span class="nottickedoff">checkArgNum formal args</span>
<span class="lineno">  714 </span><span class="spaces">      </span><span class="nottickedoff">checkArgType formal args</span>
<span class="lineno">  715 </span><span class="spaces">      </span><span class="nottickedoff">checkForArrayArg args</span></span>
<span class="lineno">  716 </span>
<span class="lineno">  717 </span>irgenStmt :: P.Statement -&gt; Semantic Statement
<span class="lineno">  718 </span><span class="decl"><span class="istickedoff">irgenStmt (P.AssignStatement loc expr) = do</span>
<span class="lineno">  719 </span><span class="spaces">  </span><span class="istickedoff">assign &lt;- irgenAssign loc expr</span>
<span class="lineno">  720 </span><span class="spaces">  </span><span class="istickedoff">return $ AssignStmt assign</span>
<span class="lineno">  721 </span><span class="spaces"></span><span class="istickedoff">irgenStmt (P.MethodCallStatement method) = <span class="nottickedoff">do</span></span>
<span class="lineno">  722 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">method' &lt;- irgenMethod method</span></span>
<span class="lineno">  723 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ MethodCallStmt method'</span></span>
<span class="lineno">  724 </span><span class="spaces"></span><span class="istickedoff">irgenStmt (P.IfStatement expr block) = <span class="nottickedoff">do</span></span>
<span class="lineno">  725 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ifBlock &lt;- irgenBlock IfBlock Nothing block</span></span>
<span class="lineno">  726 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">expr'@(SL.LocatedAt _ (Typed _ tpe)) &lt;- irgenExpr expr</span></span>
<span class="lineno">  727 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[14]</span></span>
<span class="lineno">  728 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  729 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(tpe /= BoolType)</span></span>
<span class="lineno">  730 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError $ sformat (&quot;The pred of if statment must have type bool, but got &quot; % shown % &quot; instead!&quot;) tpe)</span></span>
<span class="lineno">  731 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ IfStmt expr' ifBlock Nothing</span></span>
<span class="lineno">  732 </span><span class="spaces"></span><span class="istickedoff">irgenStmt (P.IfElseStatement expr ifBlock elseBlock) = <span class="nottickedoff">do</span></span>
<span class="lineno">  733 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">ifBlock' &lt;- irgenBlock IfBlock Nothing ifBlock</span></span>
<span class="lineno">  734 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">elseBlock' &lt;- irgenBlock IfBlock Nothing elseBlock</span></span>
<span class="lineno">  735 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">expr'@(SL.LocatedAt _ (Typed _ tpe)) &lt;- irgenExpr expr</span></span>
<span class="lineno">  736 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[14]</span></span>
<span class="lineno">  737 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  738 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(tpe /= BoolType)</span></span>
<span class="lineno">  739 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError $ sformat (&quot;The pred of if statment must have type bool, but got &quot; % shown % &quot; instead!&quot;) tpe)</span></span>
<span class="lineno">  740 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ IfStmt expr' ifBlock' (Just elseBlock')</span></span>
<span class="lineno">  741 </span><span class="spaces"></span><span class="istickedoff">irgenStmt (P.ForStatement counter counterExpr predExpr (P.CounterUpdate loc expr) block) = <span class="nottickedoff">do</span></span>
<span class="lineno">  742 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">block' &lt;- irgenBlock ForBlock Nothing block</span></span>
<span class="lineno">  743 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">counterExpr' &lt;- irgenExpr counterExpr</span></span>
<span class="lineno">  744 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">predExpr'@(SL.LocatedAt _ (Typed _ tpe)) &lt;- irgenExpr predExpr</span></span>
<span class="lineno">  745 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[14]</span></span>
<span class="lineno">  746 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  747 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(tpe /= BoolType)</span></span>
<span class="lineno">  748 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError $ sformat (&quot;The pred of for statment must have type bool, but got &quot; % shown % &quot; instead!&quot;) tpe)</span></span>
<span class="lineno">  749 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">assign &lt;- irgenAssign loc expr</span></span>
<span class="lineno">  750 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ ForStmt counter counterExpr' predExpr' assign block'</span></span>
<span class="lineno">  751 </span><span class="spaces"></span><span class="istickedoff">irgenStmt (P.WhileStatement expr block) = <span class="nottickedoff">do</span></span>
<span class="lineno">  752 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">block' &lt;- irgenBlock WhileBlock Nothing block</span></span>
<span class="lineno">  753 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">expr'@(SL.LocatedAt _ (Typed _ tpe)) &lt;- irgenExpr expr</span></span>
<span class="lineno">  754 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[14]</span></span>
<span class="lineno">  755 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  756 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(tpe /= BoolType)</span></span>
<span class="lineno">  757 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError $ sformat (&quot;The pred of while statment must have type bool, but got &quot; % shown % &quot; instead!&quot;) tpe)</span></span>
<span class="lineno">  758 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ WhileStmt expr' block'</span></span>
<span class="lineno">  759 </span><span class="spaces"></span><span class="istickedoff">irgenStmt (P.ReturnExprStatement expr) = <span class="nottickedoff">do</span></span>
<span class="lineno">  760 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">expr' &lt;- irgenExpr expr</span></span>
<span class="lineno">  761 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[8] and Semantic[9]</span></span>
<span class="lineno">  762 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">checkReturnType $ Just $ SL.unLocate expr'</span></span>
<span class="lineno">  763 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ ReturnStmt $ Just expr'</span></span>
<span class="lineno">  764 </span><span class="spaces"></span><span class="istickedoff">irgenStmt P.ReturnVoidStatement = <span class="nottickedoff">do</span></span>
<span class="lineno">  765 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[8] and Semantic[9]</span></span>
<span class="lineno">  766 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">checkReturnType Nothing</span></span>
<span class="lineno">  767 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ ReturnStmt Nothing</span></span>
<span class="lineno">  768 </span><span class="spaces"></span><span class="istickedoff">irgenStmt P.BreakStatement = <span class="nottickedoff">do</span></span>
<span class="lineno">  769 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[21]</span></span>
<span class="lineno">  770 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">inLoop &lt;- isInsideLoop</span></span>
<span class="lineno">  771 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">unless</span></span>
<span class="lineno">  772 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">inLoop</span></span>
<span class="lineno">  773 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Found break statement outside for or while block!&quot;)</span></span>
<span class="lineno">  774 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return BreakStmt</span></span>
<span class="lineno">  775 </span><span class="spaces"></span><span class="istickedoff">irgenStmt P.ContinueStatement = <span class="nottickedoff">do</span></span>
<span class="lineno">  776 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[21]</span></span>
<span class="lineno">  777 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">inLoop &lt;- isInsideLoop</span></span>
<span class="lineno">  778 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">unless</span></span>
<span class="lineno">  779 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">inLoop</span></span>
<span class="lineno">  780 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Found continue statement outside for or while block!&quot;)</span></span>
<span class="lineno">  781 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return ContinueStmt</span></span></span>
<span class="lineno">  782 </span>
<span class="lineno">  783 </span>{- generate expressions, also do type inference -}
<span class="lineno">  784 </span>irgenExpr :: SL.Located P.Expr -&gt; Semantic (SL.Located (Typed Expr))
<span class="lineno">  785 </span><span class="decl"><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.LocationExpr loc)) = do</span>
<span class="lineno">  786 </span><span class="spaces">  </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">range</span></span>
<span class="lineno">  787 </span><span class="spaces">  </span><span class="istickedoff">(Typed loc' tpe) &lt;- irgenLocation loc</span>
<span class="lineno">  788 </span><span class="spaces">  </span><span class="istickedoff">return $ SL.LocatedAt <span class="nottickedoff">range</span> $ Typed <span class="nottickedoff">(LocationExpr loc')</span> tpe</span>
<span class="lineno">  789 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.MethodCallExpr method@(P.MethodCall name _))) = <span class="nottickedoff">do</span></span>
<span class="lineno">  790 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  791 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">method' &lt;- irgenMethod method</span></span>
<span class="lineno">  792 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">m &lt;- lookupMethod' name</span></span>
<span class="lineno">  793 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">case m of</span></span>
<span class="lineno">  794 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">-- treat import methods as always return int</span></span>
<span class="lineno">  795 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Left _ -&gt; return $ SL.LocatedAt range $ Typed (MethodCallExpr method') IntType</span></span>
<span class="lineno">  796 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Right (MethodDecl (MethodSig _ tpe _) _) -&gt; do</span></span>
<span class="lineno">  797 </span><span class="spaces">      </span><span class="istickedoff"><span class="nottickedoff">case tpe of</span></span>
<span class="lineno">  798 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[6]</span></span>
<span class="lineno">  799 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Nothing -&gt;</span></span>
<span class="lineno">  800 </span><span class="spaces">          </span><span class="istickedoff"><span class="nottickedoff">throwSemanticException $</span></span>
<span class="lineno">  801 </span><span class="spaces">            </span><span class="istickedoff"><span class="nottickedoff">sformat (&quot;Method &quot; % stext % &quot; cannot be used in expressions as it returns nothing!&quot;) name</span></span>
<span class="lineno">  802 </span><span class="spaces">        </span><span class="istickedoff"><span class="nottickedoff">Just tpe' -&gt; return $ SL.LocatedAt range $ Typed (MethodCallExpr method') tpe'</span></span>
<span class="lineno">  803 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.IntLiteralExpr i)) = do</span>
<span class="lineno">  804 </span><span class="spaces">  </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">range</span></span>
<span class="lineno">  805 </span><span class="spaces">  </span><span class="istickedoff">literalVal &lt;- checkInt64Literal i</span>
<span class="lineno">  806 </span><span class="spaces">  </span><span class="istickedoff">return $ SL.LocatedAt <span class="nottickedoff">range</span> $ Typed <span class="nottickedoff">(IntLiteralExpr literalVal)</span> IntType</span>
<span class="lineno">  807 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.BoolLiteralExpr b)) = do</span>
<span class="lineno">  808 </span><span class="spaces">  </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">range</span></span>
<span class="lineno">  809 </span><span class="spaces">  </span><span class="istickedoff">lit &lt;- checkBoolLiteral b</span>
<span class="lineno">  810 </span><span class="spaces">  </span><span class="istickedoff">return $ SL.LocatedAt <span class="nottickedoff">range</span> $ Typed <span class="nottickedoff">(BoolLiteralExpr lit)</span> BoolType</span>
<span class="lineno">  811 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.CharLiteralExpr c)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  812 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  813 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">lit &lt;- checkCharLiteral c</span></span>
<span class="lineno">  814 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (CharLiteralExpr lit) IntType</span></span>
<span class="lineno">  815 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.LenExpr id)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  816 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  817 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">def &lt;- lookupVariable' id</span></span>
<span class="lineno">  818 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[13]</span></span>
<span class="lineno">  819 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">case def of</span></span>
<span class="lineno">  820 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Left (Argument nm _) -&gt; addSemanticError $ sformat (&quot;len cannot operate on argument &quot; % stext % &quot;!&quot;) nm</span></span>
<span class="lineno">  821 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Right (FieldDecl nm (ArrayType _ _)) -&gt; return ()</span></span>
<span class="lineno">  822 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">Right (FieldDecl nm _) -&gt; addSemanticError $ sformat (&quot;len cannot operate on scalar variable &quot; % stext % &quot;!&quot;) nm</span></span>
<span class="lineno">  823 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (LengthExpr id) IntType</span></span>
<span class="lineno">  824 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.ArithOpExpr op l r)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  825 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  826 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[16]</span></span>
<span class="lineno">  827 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">l'@(SL.LocatedAt _ (Typed _ ltp)) &lt;- irgenExpr l</span></span>
<span class="lineno">  828 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">r'@(SL.LocatedAt _ (Typed _ rtp)) &lt;- irgenExpr r</span></span>
<span class="lineno">  829 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  830 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(ltp /= IntType || rtp /= IntType)</span></span>
<span class="lineno">  831 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;There can only be integer values in arithmetic expressions.&quot;)</span></span>
<span class="lineno">  832 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (ArithOpExpr (parseArithOp op) l' r') IntType</span></span>
<span class="lineno">  833 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.RelOpExpr op l r)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  834 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  835 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[16]</span></span>
<span class="lineno">  836 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">l'@(SL.LocatedAt _ (Typed _ ltp)) &lt;- irgenExpr l</span></span>
<span class="lineno">  837 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">r'@(SL.LocatedAt _ (Typed _ rtp)) &lt;- irgenExpr r</span></span>
<span class="lineno">  838 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  839 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(ltp /= IntType || rtp /= IntType)</span></span>
<span class="lineno">  840 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;There can only be integer values in relational expressions.&quot;)</span></span>
<span class="lineno">  841 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (RelOpExpr (parseRelOp op) l' r') IntType</span></span>
<span class="lineno">  842 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.EqOpExpr op l r)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  843 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  844 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[17]</span></span>
<span class="lineno">  845 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">l'@(SL.LocatedAt _ (Typed _ ltp)) &lt;- irgenExpr l</span></span>
<span class="lineno">  846 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">r'@(SL.LocatedAt _ (Typed _ rtp)) &lt;- irgenExpr r</span></span>
<span class="lineno">  847 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  848 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">((ltp, rtp) /= (IntType, IntType) &amp;&amp; (ltp, rtp) /= (BoolType, BoolType))</span></span>
<span class="lineno">  849 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Can only check equality of expressions with the SAME type!&quot;)</span></span>
<span class="lineno">  850 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (EqOpExpr (parseEqOp op) l' r') BoolType</span></span>
<span class="lineno">  851 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.CondOpExpr op l r)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  852 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  853 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[18]</span></span>
<span class="lineno">  854 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">l'@(SL.LocatedAt _ (Typed _ ltp)) &lt;- irgenExpr l</span></span>
<span class="lineno">  855 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">r'@(SL.LocatedAt _ (Typed _ rtp)) &lt;- irgenExpr r</span></span>
<span class="lineno">  856 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  857 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(ltp /= BoolType || rtp /= BoolType)</span></span>
<span class="lineno">  858 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Conditional ops only accept booleans!&quot;)</span></span>
<span class="lineno">  859 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (CondOpExpr (parseCondOp op) l' r') BoolType</span></span>
<span class="lineno">  860 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.NegativeExpr expr)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  861 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  862 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[16]</span></span>
<span class="lineno">  863 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">expr'@(SL.LocatedAt _ (Typed _ tpe)) &lt;- irgenExpr expr</span></span>
<span class="lineno">  864 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  865 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(tpe /= IntType)</span></span>
<span class="lineno">  866 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Operator \&quot;-\&quot; only accepts integers!&quot;)</span></span>
<span class="lineno">  867 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (NegOpExpr Neg expr') IntType</span></span>
<span class="lineno">  868 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.NegateExpr expr)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  869 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  870 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">-- Semantic[18]</span></span>
<span class="lineno">  871 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">expr'@(SL.LocatedAt _ (Typed _ tpe)) &lt;- irgenExpr expr</span></span>
<span class="lineno">  872 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">when</span></span>
<span class="lineno">  873 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(tpe /= BoolType)</span></span>
<span class="lineno">  874 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Operator \&quot;!\&quot; only accepts integers!&quot;)</span></span>
<span class="lineno">  875 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (NotOpExpr Not expr') BoolType</span></span>
<span class="lineno">  876 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.ChoiceExpr pred l r)) = do</span>
<span class="lineno">  877 </span><span class="spaces">  </span><span class="istickedoff">updateCurrentRange <span class="nottickedoff">range</span></span>
<span class="lineno">  878 </span><span class="spaces">  </span><span class="istickedoff">pred'@(SL.LocatedAt _ (Typed _ ptp)) &lt;- irgenExpr pred</span>
<span class="lineno">  879 </span><span class="spaces">  </span><span class="istickedoff">l'@(SL.LocatedAt _ (Typed _ ltp)) &lt;- irgenExpr l</span>
<span class="lineno">  880 </span><span class="spaces">  </span><span class="istickedoff">r'@(SL.LocatedAt _ (Typed _ rtp)) &lt;- irgenExpr r</span>
<span class="lineno">  881 </span><span class="spaces">  </span><span class="istickedoff">-- Semantic[15]</span>
<span class="lineno">  882 </span><span class="spaces">  </span><span class="istickedoff">when</span>
<span class="lineno">  883 </span><span class="spaces">    </span><span class="istickedoff">(ptp /= BoolType)</span>
<span class="lineno">  884 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Predicate of choice operator must be a boolean!&quot;)</span></span>
<span class="lineno">  885 </span><span class="spaces">  </span><span class="istickedoff">when</span>
<span class="lineno">  886 </span><span class="spaces">    </span><span class="istickedoff">(ltp /= rtp)</span>
<span class="lineno">  887 </span><span class="spaces">    </span><span class="istickedoff"><span class="nottickedoff">(addSemanticError &quot;Alternatives of choice op should have same type!&quot;)</span></span>
<span class="lineno">  888 </span><span class="spaces">  </span><span class="istickedoff">return $ SL.LocatedAt <span class="nottickedoff">range</span> $ Typed <span class="nottickedoff">(ChoiceOpExpr Choice pred' l' r')</span> ltp</span>
<span class="lineno">  889 </span><span class="spaces"></span><span class="istickedoff">irgenExpr (SL.LocatedAt range (P.ParenExpr expr)) = <span class="nottickedoff">do</span></span>
<span class="lineno">  890 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">updateCurrentRange range</span></span>
<span class="lineno">  891 </span><span class="spaces">  </span><span class="istickedoff"><span class="nottickedoff">irgenExpr expr</span></span></span>
<span class="lineno">  892 </span>
<span class="lineno">  893 </span>irgenImportArg :: SL.Located P.ImportArg -&gt; Semantic (SL.Located (Typed Expr))
<span class="lineno">  894 </span><span class="decl"><span class="nottickedoff">irgenImportArg (SL.LocatedAt range (P.ExprImportArg expr)) = irgenExpr expr</span>
<span class="lineno">  895 </span><span class="spaces"></span><span class="nottickedoff">irgenImportArg (SL.LocatedAt range (P.StringImportArg arg)) = do</span>
<span class="lineno">  896 </span><span class="spaces">  </span><span class="nottickedoff">updateCurrentRange range</span>
<span class="lineno">  897 </span><span class="spaces">  </span><span class="nottickedoff">return $ SL.LocatedAt range $ Typed (StringLiteralExpr arg) StringType</span></span>

</pre>
</body>
</html>
