-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/zhangjunphy/decaf#README.md</a>
@package decaf
@version 0.1.0.0

module CodeGen

module Configuration.Types
data Configuration
Configuration :: FilePath -> Maybe CompilerStage -> Bool -> OptimizationSpecification -> Maybe FilePath -> Configuration
[$sel:input:Configuration] :: Configuration -> FilePath
[$sel:explicitTarget:Configuration] :: Configuration -> Maybe CompilerStage
[$sel:debug:Configuration] :: Configuration -> Bool
[$sel:opt:Configuration] :: Configuration -> OptimizationSpecification
[$sel:outputFileName:Configuration] :: Configuration -> Maybe FilePath
defaultConfiguration :: Configuration
data CompilerStage
Scan :: CompilerStage
Parse :: CompilerStage
Cfg :: CompilerStage
Inter :: CompilerStage
Assembly :: CompilerStage
data OptimizationSpecification
All :: OptimizationSpecification
Some :: [OptimizationName] -> OptimizationSpecification
data OptimizationName
Enable :: String -> OptimizationName
Disable :: String -> OptimizationName
instance GHC.Classes.Ord Configuration.Types.CompilerStage
instance GHC.Classes.Eq Configuration.Types.CompilerStage
instance GHC.Classes.Eq Configuration.Types.OptimizationName
instance GHC.Classes.Eq Configuration.Types.OptimizationSpecification
instance GHC.Classes.Eq Configuration.Types.Configuration
instance GHC.Show.Show Configuration.Types.CompilerStage
instance GHC.Read.Read Configuration.Types.CompilerStage

module Configuration
data Configuration
($sel:input:Configuration) :: Configuration -> FilePath
target :: Configuration -> CompilerStage
($sel:debug:Configuration) :: Configuration -> Bool
($sel:opt:Configuration) :: Configuration -> OptimizationSpecification
($sel:outputFileName:Configuration) :: Configuration -> Maybe FilePath
defaultConfiguration :: Configuration
data CompilerStage
Scan :: CompilerStage
Parse :: CompilerStage
Cfg :: CompilerStage
Inter :: CompilerStage
Assembly :: CompilerStage
data OptimizationSpecification
All :: OptimizationSpecification
Some :: [OptimizationName] -> OptimizationSpecification
data OptimizationName
Enable :: String -> OptimizationName
Disable :: String -> OptimizationName

module Constants
globalScopeID :: Int
mainMethodName :: Text

module DominatorTree

module Lexer.Token

-- | A token.
data Token
Keyword :: !Text -> Token
Identifier :: !Text -> Token
CharLiteral :: !Text -> Token
IntLiteral :: !Text -> Token
BooleanLiteral :: !Text -> Token
StringLiteral :: !Text -> Token
AssignOp :: Token
CompoundAssignOp :: !Text -> Token
IncrementOp :: !Text -> Token
ArithmeticOp :: !Text -> Token
RelationOp :: !Text -> Token
EquationOp :: !Text -> Token
ConditionOp :: !Text -> Token
LCurly :: Token
RCurly :: Token
LParen :: Token
RParen :: Token
LBrack :: Token
RBrack :: Token
Choice :: Token
Colon :: Token
Semicolon :: Token
Comma :: Token
Negate :: Token
EOF :: Token
Error :: !Text -> Token
instance GHC.Classes.Eq Lexer.Token.Token
instance GHC.Show.Show Lexer.Token.Token

module Types
type VID = Int
type Name = Text
type ScopeID = Int
type BBID = Int

module Util.CLI
generateUsage :: IO String

-- | Parses command-line options, returning a <a>Configuration</a>
--   describing the behavior of the compiler.
getConfiguration :: IO (Either String Configuration)

module Util.Graph
data Graph ni nd ed
Graph :: Map ni nd -> Map ni [(ni, ed)] -> Graph ni nd ed
[$sel:nodes:Graph] :: Graph ni nd ed -> Map ni nd
[$sel:edges:Graph] :: Graph ni nd ed -> Map ni [(ni, ed)]
type GraphException = Text
empty :: Graph ni nd ed
outBound :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> [(ni, ed)]
inBound :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> [(ni, ed)]
lookupNode :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> Maybe nd
updateNodeWith :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> (Maybe nd -> nd) -> Graph ni nd ed
updateNode :: (Eq ni, Ord ni) => ni -> nd -> Graph ni nd ed -> Graph ni nd ed
union :: (Eq ni, Ord ni) => Graph ni nd ed -> Graph ni nd ed -> Graph ni nd ed
newtype GraphBuilder ni nd ed a
GraphBuilder :: ExceptT GraphException (State (Graph ni nd ed)) a -> GraphBuilder ni nd ed a
[$sel:buildGraph:GraphBuilder] :: GraphBuilder ni nd ed a -> ExceptT GraphException (State (Graph ni nd ed)) a
addNode :: (Eq ni, Ord ni) => ni -> nd -> GraphBuilder ni nd ed ni
addEdge :: (Eq ni, Ord ni) => ni -> ni -> ed -> GraphBuilder ni nd ed ()
deleteNode :: (Eq ni, Ord ni) => ni -> GraphBuilder ni nd ed ()
deleteEdge :: (Eq ni, Ord ni) => ni -> ni -> GraphBuilder ni nd ed ()
update :: (Eq ni, Ord ni) => GraphBuilder ni nd ed a -> Graph ni nd ed -> Either Text (Graph ni nd ed)
build :: (Eq ni, Ord ni) => GraphBuilder ni nd ed a -> Either Text (Graph ni nd ed)
traverseM_ :: (Eq ni, Ord ni, Monad m) => (ni -> nd -> m a) -> Graph ni nd ed -> m ()
newtype Memoize ni m a
Memoize :: State m a -> Memoize ni m a
[$sel:unmem:Memoize] :: Memoize ni m a -> State m a
data Memory ni
Memory :: !Set ni -> !Map ni (Set ni) -> Memory ni
[$sel:processing:Memory] :: Memory ni -> !Set ni
[$sel:finished:Memory] :: Memory ni -> !Map ni (Set ni)
recurse_ :: (Eq ni, Ord ni) => (ni -> Graph ni nd ed -> [ni]) -> ni -> Graph ni nd ed -> Memoize ni (Memory ni) (Set ni)
strictlyDominate :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> Set ni
strictlyPostDominate :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> Set ni
instance (GHC.Show.Show ni, GHC.Show.Show nd, GHC.Show.Show ed) => GHC.Show.Show (Util.Graph.Graph ni nd ed)
instance Control.Monad.State.Class.MonadState (Util.Graph.Graph ni nd ed) (Util.Graph.GraphBuilder ni nd ed)
instance Control.Monad.Error.Class.MonadError Util.Graph.GraphException (Util.Graph.GraphBuilder ni nd ed)
instance GHC.Base.Monad (Util.Graph.GraphBuilder ni nd ed)
instance GHC.Base.Applicative (Util.Graph.GraphBuilder ni nd ed)
instance GHC.Base.Functor (Util.Graph.GraphBuilder ni nd ed)
instance Control.Monad.State.Class.MonadState m (Util.Graph.Memoize ni m)
instance GHC.Base.Monad (Util.Graph.Memoize ni m)
instance GHC.Base.Applicative (Util.Graph.Memoize ni m)
instance GHC.Base.Functor (Util.Graph.Memoize ni m)
instance GHC.Generics.Generic (Util.Graph.Memory ni)

module Util.SourceLoc
data Posn
Posn :: !Int -> !Int -> !Int -> Posn
[$sel:offset:Posn] :: Posn -> !Int
[$sel:row:Posn] :: Posn -> !Int
[$sel:col:Posn] :: Posn -> !Int
data Range
Range :: Posn -> Posn -> Range
[$sel:start:Range] :: Range -> Posn
[$sel:stop:Range] :: Range -> Posn
data Located a
LocatedAt :: Range -> a -> Located a
unLoc :: Located a -> a
getLoc :: Located a -> Range
instance GHC.Classes.Ord Util.SourceLoc.Posn
instance GHC.Classes.Eq Util.SourceLoc.Posn
instance GHC.Classes.Ord Util.SourceLoc.Range
instance GHC.Classes.Eq Util.SourceLoc.Range
instance GHC.Base.Functor Util.SourceLoc.Located
instance GHC.Show.Show a => GHC.Show.Show (Util.SourceLoc.Located a)
instance GHC.Show.Show Util.SourceLoc.Range
instance GHC.Show.Show Util.SourceLoc.Posn

module Lexer.Lex
newtype Alex a
Alex :: (AlexState -> Either String (AlexState, a)) -> Alex a
[$sel:unAlex:Alex] :: Alex a -> AlexState -> Either String (AlexState, a)
alexMonadScan :: Alex (Located Token)
runAlex :: ByteString -> Alex a -> Either String a
data AlexState
AlexState :: !AlexPosn -> !Int64 -> ByteString -> !Char -> !Int -> AlexUserState -> AlexState
[$sel:alex_pos:AlexState] :: AlexState -> !AlexPosn
[$sel:alex_bpos:AlexState] :: AlexState -> !Int64
[$sel:alex_inp:AlexState] :: AlexState -> ByteString
[$sel:alex_chr:AlexState] :: AlexState -> !Char
[$sel:alex_scd:AlexState] :: AlexState -> !Int
[$sel:alex_ust:AlexState] :: AlexState -> AlexUserState
data AlexUserState
AlexUserState :: Int -> Bool -> Bool -> ByteString -> [ByteString] -> AlexUserState
[$sel:lexerCommentDepth:AlexUserState] :: AlexUserState -> Int
[$sel:lexerStringState:AlexUserState] :: AlexUserState -> Bool
[$sel:lexerCharState:AlexUserState] :: AlexUserState -> Bool
[$sel:lexerStringValue:AlexUserState] :: AlexUserState -> ByteString
[$sel:inputLines:AlexUserState] :: AlexUserState -> [ByteString]
instance GHC.Classes.Ord Lexer.Lex.AlexPosn
instance GHC.Show.Show Lexer.Lex.AlexPosn
instance GHC.Classes.Eq Lexer.Lex.AlexPosn
instance GHC.Base.Functor Lexer.Lex.Alex
instance GHC.Base.Applicative Lexer.Lex.Alex
instance GHC.Base.Monad Lexer.Lex.Alex

module Lexer

-- | A token.
data Token
Keyword :: !Text -> Token
Identifier :: !Text -> Token
CharLiteral :: !Text -> Token
IntLiteral :: !Text -> Token
BooleanLiteral :: !Text -> Token
StringLiteral :: !Text -> Token
AssignOp :: Token
CompoundAssignOp :: !Text -> Token
IncrementOp :: !Text -> Token
ArithmeticOp :: !Text -> Token
RelationOp :: !Text -> Token
EquationOp :: !Text -> Token
ConditionOp :: !Text -> Token
LCurly :: Token
RCurly :: Token
LParen :: Token
RParen :: Token
LBrack :: Token
RBrack :: Token
Choice :: Token
Colon :: Token
Semicolon :: Token
Comma :: Token
Negate :: Token
EOF :: Token
Error :: !Text -> Token
newtype Alex a
Alex :: (AlexState -> Either String (AlexState, a)) -> Alex a
[$sel:unAlex:Alex] :: Alex a -> AlexState -> Either String (AlexState, a)
scan :: ByteString -> [Either String (Located Token)]
formatTokenOrError :: Either String (Located Token) -> Either String String
alexMonadScan :: Alex (Located Token)
runAlex :: ByteString -> Alex a -> Either String a

module Parser.Parser
parse :: ByteString -> Either String Program
data Program
Program :: [Located ImportDecl] -> [Located FieldDecl] -> [Located MethodDecl] -> Program
[$sel:importDecls:Program] :: Program -> [Located ImportDecl]
[$sel:fieldDecls:Program] :: Program -> [Located FieldDecl]
[$sel:methodDecls:Program] :: Program -> [Located MethodDecl]
data ImportDecl
ImportDecl :: Text -> ImportDecl
[$sel:importId:ImportDecl] :: ImportDecl -> Text
data FieldDecl
FieldDecl :: Type -> [Located FieldElem] -> FieldDecl
[$sel:fieldType:FieldDecl] :: FieldDecl -> Type
[$sel:elems:FieldDecl] :: FieldDecl -> [Located FieldElem]
data MethodDecl
MethodDecl :: Text -> Maybe Type -> [Located Argument] -> Block -> MethodDecl
[$sel:methodId:MethodDecl] :: MethodDecl -> Text
[$sel:returnType:MethodDecl] :: MethodDecl -> Maybe Type
[$sel:arguments:MethodDecl] :: MethodDecl -> [Located Argument]
[$sel:block:MethodDecl] :: MethodDecl -> Block
data FieldElem
ScalarField :: Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
VectorField :: Text -> Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
[$sel:size:ScalarField] :: FieldElem -> Text
data Type
IntType :: Type
BoolType :: Type
data Argument
Argument :: Text -> Type -> Argument
[$sel:argumentId:Argument] :: Argument -> Text
[$sel:argumentType:Argument] :: Argument -> Type
data Block
Block :: [Located FieldDecl] -> [Located Statement] -> Block
[$sel:blockFieldDecls:Block] :: Block -> [Located FieldDecl]
[$sel:blockStatements:Block] :: Block -> [Located Statement]
data Statement
AssignStatement :: Location -> AssignExpr -> Statement
[$sel:assignLocation:AssignStatement] :: Statement -> Location
[$sel:assignExpr:AssignStatement] :: Statement -> AssignExpr
MethodCallStatement :: MethodCall -> Statement
[$sel:methodCallStatement:AssignStatement] :: Statement -> MethodCall
IfStatement :: Located Expr -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
IfElseStatement :: Located Expr -> Block -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
[$sel:elseBlock:AssignStatement] :: Statement -> Block
ForStatement :: Text -> Located Expr -> Located Expr -> CounterUpdate -> Block -> Statement
[$sel:counterId:AssignStatement] :: Statement -> Text
[$sel:counterExpr:AssignStatement] :: Statement -> Located Expr
[$sel:forPredExpr:AssignStatement] :: Statement -> Located Expr
[$sel:counterUpdate:AssignStatement] :: Statement -> CounterUpdate
[$sel:forBlock:AssignStatement] :: Statement -> Block
WhileStatement :: Located Expr -> Block -> Statement
[$sel:whileExpr:AssignStatement] :: Statement -> Located Expr
[$sel:whileBlock:AssignStatement] :: Statement -> Block
ReturnVoidStatement :: Statement
ReturnExprStatement :: Located Expr -> Statement
[$sel:returnExpr:AssignStatement] :: Statement -> Located Expr
BreakStatement :: Statement
ContinueStatement :: Statement
ErrorStatement :: Statement
data Location
ScalarLocation :: Text -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
VectorLocation :: Text -> Located Expr -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
[$sel:arrayIndexExpr:ScalarLocation] :: Location -> Located Expr
data AssignExpr
AssignExpr :: Text -> Located Expr -> AssignExpr
[$sel:assignOp:AssignExpr] :: AssignExpr -> Text
[$sel:assignSourceExpr:AssignExpr] :: AssignExpr -> Located Expr
IncrementExpr :: Text -> AssignExpr
[$sel:incrementOp:AssignExpr] :: AssignExpr -> Text
data MethodCall
MethodCall :: Text -> [Located ImportArg] -> MethodCall
[$sel:methodName:MethodCall] :: MethodCall -> Text
[$sel:importArguments:MethodCall] :: MethodCall -> [Located ImportArg]
data ImportArg
ExprImportArg :: Located Expr -> ImportArg
[$sel:argumentExpr:ExprImportArg] :: ImportArg -> Located Expr
StringImportArg :: Text -> ImportArg
[$sel:argumentString:ExprImportArg] :: ImportArg -> Text
data CounterUpdate
CounterUpdate :: Location -> AssignExpr -> CounterUpdate
[$sel:counterLocation:CounterUpdate] :: CounterUpdate -> Location
[$sel:updateExpr:CounterUpdate] :: CounterUpdate -> AssignExpr
data Expr
LocationExpr :: Location -> Expr
[$sel:location:LocationExpr] :: Expr -> Location
MethodCallExpr :: MethodCall -> Expr
[$sel:methodCallExpr:LocationExpr] :: Expr -> MethodCall
IntLiteralExpr :: Text -> Expr
[$sel:intLiteral:LocationExpr] :: Expr -> Text
CharLiteralExpr :: Text -> Expr
[$sel:charLiteral:LocationExpr] :: Expr -> Text
BoolLiteralExpr :: Text -> Expr
[$sel:boolLiteral:LocationExpr] :: Expr -> Text
LenExpr :: Text -> Expr
[$sel:lenId:LocationExpr] :: Expr -> Text
ArithOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:arithOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
RelOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:relOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
EqOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:eqOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
CondOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:condOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
NegativeExpr :: Located Expr -> Expr
[$sel:negativeExpr:LocationExpr] :: Expr -> Located Expr
NegateExpr :: Located Expr -> Expr
[$sel:negateExpr:LocationExpr] :: Expr -> Located Expr
ParenExpr :: Located Expr -> Expr
[$sel:parenExpr:LocationExpr] :: Expr -> Located Expr
ChoiceExpr :: Located Expr -> Located Expr -> Located Expr -> Expr
[$sel:choicePredExpr:LocationExpr] :: Expr -> Located Expr
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
instance GHC.Show.Show Parser.Parser.ImportDecl
instance GHC.Show.Show Parser.Parser.FieldElem
instance GHC.Show.Show Parser.Parser.Type
instance GHC.Show.Show Parser.Parser.FieldDecl
instance GHC.Show.Show Parser.Parser.Argument
instance GHC.Show.Show Parser.Parser.Location
instance GHC.Show.Show Parser.Parser.ImportArg
instance GHC.Show.Show Parser.Parser.MethodCall
instance GHC.Show.Show Parser.Parser.Expr
instance GHC.Show.Show Parser.Parser.AssignExpr
instance GHC.Show.Show Parser.Parser.CounterUpdate
instance GHC.Show.Show Parser.Parser.Block
instance GHC.Show.Show Parser.Parser.Statement
instance GHC.Show.Show Parser.Parser.MethodDecl
instance GHC.Show.Show Parser.Parser.Program

module Parser
parse :: ByteString -> Either String Program
data Program
Program :: [Located ImportDecl] -> [Located FieldDecl] -> [Located MethodDecl] -> Program
[$sel:importDecls:Program] :: Program -> [Located ImportDecl]
[$sel:fieldDecls:Program] :: Program -> [Located FieldDecl]
[$sel:methodDecls:Program] :: Program -> [Located MethodDecl]
data ImportDecl
ImportDecl :: Text -> ImportDecl
[$sel:importId:ImportDecl] :: ImportDecl -> Text
data FieldDecl
FieldDecl :: Type -> [Located FieldElem] -> FieldDecl
[$sel:fieldType:FieldDecl] :: FieldDecl -> Type
[$sel:elems:FieldDecl] :: FieldDecl -> [Located FieldElem]
data MethodDecl
MethodDecl :: Text -> Maybe Type -> [Located Argument] -> Block -> MethodDecl
[$sel:methodId:MethodDecl] :: MethodDecl -> Text
[$sel:returnType:MethodDecl] :: MethodDecl -> Maybe Type
[$sel:arguments:MethodDecl] :: MethodDecl -> [Located Argument]
[$sel:block:MethodDecl] :: MethodDecl -> Block
data FieldElem
ScalarField :: Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
VectorField :: Text -> Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
[$sel:size:ScalarField] :: FieldElem -> Text
data Type
IntType :: Type
BoolType :: Type
data Argument
Argument :: Text -> Type -> Argument
[$sel:argumentId:Argument] :: Argument -> Text
[$sel:argumentType:Argument] :: Argument -> Type
data Block
Block :: [Located FieldDecl] -> [Located Statement] -> Block
[$sel:blockFieldDecls:Block] :: Block -> [Located FieldDecl]
[$sel:blockStatements:Block] :: Block -> [Located Statement]
data Statement
AssignStatement :: Location -> AssignExpr -> Statement
[$sel:assignLocation:AssignStatement] :: Statement -> Location
[$sel:assignExpr:AssignStatement] :: Statement -> AssignExpr
MethodCallStatement :: MethodCall -> Statement
[$sel:methodCallStatement:AssignStatement] :: Statement -> MethodCall
IfStatement :: Located Expr -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
IfElseStatement :: Located Expr -> Block -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
[$sel:elseBlock:AssignStatement] :: Statement -> Block
ForStatement :: Text -> Located Expr -> Located Expr -> CounterUpdate -> Block -> Statement
[$sel:counterId:AssignStatement] :: Statement -> Text
[$sel:counterExpr:AssignStatement] :: Statement -> Located Expr
[$sel:forPredExpr:AssignStatement] :: Statement -> Located Expr
[$sel:counterUpdate:AssignStatement] :: Statement -> CounterUpdate
[$sel:forBlock:AssignStatement] :: Statement -> Block
WhileStatement :: Located Expr -> Block -> Statement
[$sel:whileExpr:AssignStatement] :: Statement -> Located Expr
[$sel:whileBlock:AssignStatement] :: Statement -> Block
ReturnVoidStatement :: Statement
ReturnExprStatement :: Located Expr -> Statement
[$sel:returnExpr:AssignStatement] :: Statement -> Located Expr
BreakStatement :: Statement
ContinueStatement :: Statement
ErrorStatement :: Statement
data Location
ScalarLocation :: Text -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
VectorLocation :: Text -> Located Expr -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
[$sel:arrayIndexExpr:ScalarLocation] :: Location -> Located Expr
data AssignExpr
AssignExpr :: Text -> Located Expr -> AssignExpr
[$sel:assignOp:AssignExpr] :: AssignExpr -> Text
[$sel:assignSourceExpr:AssignExpr] :: AssignExpr -> Located Expr
IncrementExpr :: Text -> AssignExpr
[$sel:incrementOp:AssignExpr] :: AssignExpr -> Text
data MethodCall
MethodCall :: Text -> [Located ImportArg] -> MethodCall
[$sel:methodName:MethodCall] :: MethodCall -> Text
[$sel:importArguments:MethodCall] :: MethodCall -> [Located ImportArg]
data ImportArg
ExprImportArg :: Located Expr -> ImportArg
[$sel:argumentExpr:ExprImportArg] :: ImportArg -> Located Expr
StringImportArg :: Text -> ImportArg
[$sel:argumentString:ExprImportArg] :: ImportArg -> Text
data CounterUpdate
CounterUpdate :: Location -> AssignExpr -> CounterUpdate
[$sel:counterLocation:CounterUpdate] :: CounterUpdate -> Location
[$sel:updateExpr:CounterUpdate] :: CounterUpdate -> AssignExpr
data Expr
LocationExpr :: Location -> Expr
[$sel:location:LocationExpr] :: Expr -> Location
MethodCallExpr :: MethodCall -> Expr
[$sel:methodCallExpr:LocationExpr] :: Expr -> MethodCall
IntLiteralExpr :: Text -> Expr
[$sel:intLiteral:LocationExpr] :: Expr -> Text
CharLiteralExpr :: Text -> Expr
[$sel:charLiteral:LocationExpr] :: Expr -> Text
BoolLiteralExpr :: Text -> Expr
[$sel:boolLiteral:LocationExpr] :: Expr -> Text
LenExpr :: Text -> Expr
[$sel:lenId:LocationExpr] :: Expr -> Text
ArithOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:arithOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
RelOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:relOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
EqOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:eqOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
CondOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:condOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
NegativeExpr :: Located Expr -> Expr
[$sel:negativeExpr:LocationExpr] :: Expr -> Located Expr
NegateExpr :: Located Expr -> Expr
[$sel:negateExpr:LocationExpr] :: Expr -> Located Expr
ParenExpr :: Located Expr -> Expr
[$sel:parenExpr:LocationExpr] :: Expr -> Located Expr
ChoiceExpr :: Located Expr -> Located Expr -> Located Expr -> Expr
[$sel:choicePredExpr:LocationExpr] :: Expr -> Located Expr
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr

module AST
data RelOp
LessThan :: RelOp
GreaterThan :: RelOp
LessEqual :: RelOp
GreaterEqual :: RelOp
data ArithOp
Plus :: ArithOp
Minus :: ArithOp
Multiply :: ArithOp
Division :: ArithOp
Modulo :: ArithOp
data EqOp
Equal :: EqOp
NotEqual :: EqOp
data CondOp
Or :: CondOp
And :: CondOp
data NegOp
Neg :: NegOp
data NotOp
Not :: NotOp
data ChoiceOp
Choice :: ChoiceOp
data AssignOp
EqlAssign :: AssignOp
IncAssign :: AssignOp
DecAssign :: AssignOp
PlusPlus :: AssignOp
MinusMinus :: AssignOp
data Type
Void :: Type
IntType :: Type
BoolType :: Type
StringType :: Type
ArrayType :: !Type -> !Int64 -> Type
Ptr :: !Type -> Type
dataSize :: Type -> Maybe Int64
parseArithOp :: Text -> ArithOp
parseRelOp :: Text -> RelOp
parseEqOp :: Text -> EqOp
parseCondOp :: Text -> CondOp
parseNegOp :: Text -> NegOp
parseNotOp :: Text -> NotOp
parseAssignOp :: Text -> AssignOp
data Location
Location :: Name -> Maybe Expr -> Either Argument FieldDecl -> Type -> Range -> Location
[$sel:name:Location] :: Location -> Name
[$sel:idx:Location] :: Location -> Maybe Expr
[$sel:variableDef:Location] :: Location -> Either Argument FieldDecl
[$sel:tpe:Location] :: Location -> Type
[$sel:loc:Location] :: Location -> Range
typeOfDef :: Either Argument FieldDecl -> Type
data Assignment
Assignment :: Location -> AssignOp -> Maybe Expr -> Range -> Assignment
[$sel:location:Assignment] :: Assignment -> Location
[$sel:op:Assignment] :: Assignment -> AssignOp
[$sel:expr:Assignment] :: Assignment -> Maybe Expr
[$sel:loc:Assignment] :: Assignment -> Range
data MethodCall
MethodCall :: Name -> [Expr] -> Range -> MethodCall
[$sel:name:MethodCall] :: MethodCall -> Name
[$sel:args:MethodCall] :: MethodCall -> [Expr]
[$sel:loc:MethodCall] :: MethodCall -> Range
data ASTRoot
ASTRoot :: [ImportDecl] -> [FieldDecl] -> [MethodDecl] -> ASTRoot
[$sel:imports:ASTRoot] :: ASTRoot -> [ImportDecl]
[$sel:vars:ASTRoot] :: ASTRoot -> [FieldDecl]
[$sel:methods:ASTRoot] :: ASTRoot -> [MethodDecl]
data ImportDecl
ImportDecl :: Name -> Range -> ImportDecl
[$sel:name:ImportDecl] :: ImportDecl -> Name
[$sel:loc:ImportDecl] :: ImportDecl -> Range
data FieldDecl
FieldDecl :: Name -> Type -> Range -> FieldDecl
[$sel:name:FieldDecl] :: FieldDecl -> Name
[$sel:tpe:FieldDecl] :: FieldDecl -> Type
[$sel:loc:FieldDecl] :: FieldDecl -> Range
data Argument
Argument :: Name -> Type -> Range -> Argument
[$sel:name:Argument] :: Argument -> Name
[$sel:tpe:Argument] :: Argument -> Type
[$sel:loc:Argument] :: Argument -> Range
data MethodSig
MethodSig :: Name -> Maybe Type -> [Argument] -> MethodSig
[$sel:name:MethodSig] :: MethodSig -> Name
[$sel:tpe:MethodSig] :: MethodSig -> Maybe Type
[$sel:args:MethodSig] :: MethodSig -> [Argument]
data MethodDecl
MethodDecl :: MethodSig -> Block -> Range -> MethodDecl
[$sel:sig:MethodDecl] :: MethodDecl -> MethodSig
[$sel:block:MethodDecl] :: MethodDecl -> Block
[$sel:loc:MethodDecl] :: MethodDecl -> Range
data Statement
Statement :: Statement_ -> Range -> Statement
[$sel:statement_:Statement] :: Statement -> Statement_
[$sel:loc:Statement] :: Statement -> Range
data Statement_
AssignStmt :: Assignment -> Statement_
[$sel:assign:AssignStmt] :: Statement_ -> Assignment
IfStmt :: Expr -> Block -> Maybe Block -> Statement_
[$sel:pred:AssignStmt] :: Statement_ -> Expr
[$sel:ifBlock:AssignStmt] :: Statement_ -> Block
[$sel:elseBlock:AssignStmt] :: Statement_ -> Maybe Block
ForStmt :: Name -> Expr -> Expr -> Assignment -> Block -> Statement_
[$sel:counter:AssignStmt] :: Statement_ -> Name
[$sel:initCounter:AssignStmt] :: Statement_ -> Expr
[$sel:pred:AssignStmt] :: Statement_ -> Expr
[$sel:update:AssignStmt] :: Statement_ -> Assignment
[$sel:block:AssignStmt] :: Statement_ -> Block
WhileStmt :: Expr -> Block -> Statement_
[$sel:pred:AssignStmt] :: Statement_ -> Expr
[$sel:block:AssignStmt] :: Statement_ -> Block
ReturnStmt :: Maybe Expr -> Statement_
[$sel:expr:AssignStmt] :: Statement_ -> Maybe Expr
MethodCallStmt :: MethodCall -> Statement_
[$sel:methodCall:AssignStmt] :: Statement_ -> MethodCall
BreakStmt :: Statement_
ContinueStmt :: Statement_
data Expr
Expr :: Expr_ -> Type -> Range -> Expr
[$sel:expr_:Expr] :: Expr -> Expr_
[$sel:tpe:Expr] :: Expr -> Type
[$sel:loc:Expr] :: Expr -> Range
data Expr_
LocationExpr :: Location -> Expr_
[$sel:location:LocationExpr] :: Expr_ -> Location
MethodCallExpr :: MethodCall -> Expr_
[$sel:methodCall:LocationExpr] :: Expr_ -> MethodCall
ExternCallExpr :: Name -> [Expr] -> Expr_
[$sel:name:LocationExpr] :: Expr_ -> Name
[$sel:args:LocationExpr] :: Expr_ -> [Expr]
IntLiteralExpr :: Int64 -> Expr_
[$sel:intVal:LocationExpr] :: Expr_ -> Int64
BoolLiteralExpr :: Bool -> Expr_
[$sel:boolVal:LocationExpr] :: Expr_ -> Bool
CharLiteralExpr :: Char -> Expr_
[$sel:charVal:LocationExpr] :: Expr_ -> Char
StringLiteralExpr :: Text -> Expr_
[$sel:strVal:LocationExpr] :: Expr_ -> Text
ArithOpExpr :: ArithOp -> Expr -> Expr -> Expr_
[$sel:arithOp:LocationExpr] :: Expr_ -> ArithOp
[$sel:lhs:LocationExpr] :: Expr_ -> Expr
[$sel:rhs:LocationExpr] :: Expr_ -> Expr
RelOpExpr :: RelOp -> Expr -> Expr -> Expr_
[$sel:relOp:LocationExpr] :: Expr_ -> RelOp
[$sel:lhs:LocationExpr] :: Expr_ -> Expr
[$sel:rhs:LocationExpr] :: Expr_ -> Expr
CondOpExpr :: CondOp -> Expr -> Expr -> Expr_
[$sel:condOp:LocationExpr] :: Expr_ -> CondOp
[$sel:lhs:LocationExpr] :: Expr_ -> Expr
[$sel:rhs:LocationExpr] :: Expr_ -> Expr
EqOpExpr :: EqOp -> Expr -> Expr -> Expr_
[$sel:eqOp:LocationExpr] :: Expr_ -> EqOp
[$sel:lhs:LocationExpr] :: Expr_ -> Expr
[$sel:rhs:LocationExpr] :: Expr_ -> Expr
NegOpExpr :: NegOp -> Expr -> Expr_
[$sel:negOp:LocationExpr] :: Expr_ -> NegOp
[$sel:expr:LocationExpr] :: Expr_ -> Expr
NotOpExpr :: NotOp -> Expr -> Expr_
[$sel:notOp:LocationExpr] :: Expr_ -> NotOp
[$sel:expr:LocationExpr] :: Expr_ -> Expr
ChoiceOpExpr :: ChoiceOp -> Expr -> Expr -> Expr -> Expr_
[$sel:choiceOp:LocationExpr] :: Expr_ -> ChoiceOp
[$sel:expr1:LocationExpr] :: Expr_ -> Expr
[$sel:expr2:LocationExpr] :: Expr_ -> Expr
[$sel:expr3:LocationExpr] :: Expr_ -> Expr
LengthExpr :: Name -> Expr_
[$sel:name:LocationExpr] :: Expr_ -> Name
data Typed a
Typed :: a -> Type -> Typed a
[$sel:ele:Typed] :: Typed a -> a
[$sel:tpe:Typed] :: Typed a -> Type
data Block
Block :: [FieldDecl] -> [Statement] -> ScopeID -> Block
[$sel:vars:Block] :: Block -> [FieldDecl]
[$sel:stmts:Block] :: Block -> [Statement]
[$sel:blockID:Block] :: Block -> ScopeID
instance GHC.Classes.Eq AST.RelOp
instance GHC.Classes.Eq AST.ArithOp
instance GHC.Classes.Eq AST.EqOp
instance GHC.Classes.Eq AST.CondOp
instance GHC.Classes.Eq AST.NegOp
instance GHC.Classes.Eq AST.NotOp
instance GHC.Classes.Eq AST.ChoiceOp
instance GHC.Show.Show AST.ChoiceOp
instance GHC.Classes.Eq AST.AssignOp
instance GHC.Classes.Eq AST.Type
instance GHC.Show.Show AST.ImportDecl
instance GHC.Generics.Generic AST.ImportDecl
instance GHC.Show.Show AST.FieldDecl
instance GHC.Generics.Generic AST.FieldDecl
instance GHC.Show.Show AST.Argument
instance GHC.Generics.Generic AST.Argument
instance GHC.Show.Show AST.MethodSig
instance GHC.Generics.Generic AST.MethodSig
instance GHC.Generics.Generic AST.Location
instance GHC.Show.Show AST.MethodCall
instance GHC.Generics.Generic AST.MethodCall
instance GHC.Show.Show AST.Expr
instance GHC.Generics.Generic AST.Expr
instance GHC.Show.Show AST.Expr_
instance GHC.Generics.Generic AST.Expr_
instance GHC.Show.Show AST.Assignment
instance GHC.Generics.Generic AST.Assignment
instance GHC.Show.Show a => GHC.Show.Show (AST.Typed a)
instance GHC.Generics.Generic (AST.Typed a)
instance GHC.Show.Show AST.Statement_
instance GHC.Generics.Generic AST.Statement_
instance GHC.Show.Show AST.Statement
instance GHC.Generics.Generic AST.Statement
instance GHC.Show.Show AST.Block
instance GHC.Generics.Generic AST.Block
instance GHC.Show.Show AST.MethodDecl
instance GHC.Generics.Generic AST.MethodDecl
instance GHC.Show.Show AST.ASTRoot
instance GHC.Generics.Generic AST.ASTRoot
instance GHC.Show.Show AST.Location
instance GHC.Show.Show AST.Type
instance GHC.Show.Show AST.AssignOp
instance GHC.Show.Show AST.NotOp
instance GHC.Show.Show AST.NegOp
instance GHC.Show.Show AST.CondOp
instance GHC.Show.Show AST.EqOp
instance GHC.Show.Show AST.ArithOp
instance GHC.Show.Show AST.RelOp

module Semantic
runSemanticAnalysis :: Program -> Either String (ASTRoot, [SemanticError], SemanticInfo)
data SymbolTable
SymbolTable :: ScopeID -> Maybe SymbolTable -> Maybe (Map Name ImportDecl) -> Map Name FieldDecl -> Maybe (Map Name MethodDecl) -> Maybe (Map Name Argument) -> BlockType -> Maybe MethodSig -> SymbolTable
[$sel:scopeID:SymbolTable] :: SymbolTable -> ScopeID
[$sel:parent:SymbolTable] :: SymbolTable -> Maybe SymbolTable
[$sel:importSymbols:SymbolTable] :: SymbolTable -> Maybe (Map Name ImportDecl)
[$sel:variableSymbols:SymbolTable] :: SymbolTable -> Map Name FieldDecl
[$sel:methodSymbols:SymbolTable] :: SymbolTable -> Maybe (Map Name MethodDecl)
[$sel:arguments:SymbolTable] :: SymbolTable -> Maybe (Map Name Argument)
[$sel:blockType:SymbolTable] :: SymbolTable -> BlockType
[$sel:methodSig:SymbolTable] :: SymbolTable -> Maybe MethodSig
data SemanticInfo
SemanticInfo :: !Map ScopeID SymbolTable -> !Map ScopeID (Set (ScopeID, Name)) -> SemanticInfo
[$sel:symbolTables:SemanticInfo] :: SemanticInfo -> !Map ScopeID SymbolTable
[$sel:symbolWrites:SemanticInfo] :: SemanticInfo -> !Map ScopeID (Set (ScopeID, Name))
type ScopeID = Int
data BlockType
RootBlock :: BlockType
IfBlock :: BlockType
ForBlock :: BlockType
WhileBlock :: BlockType
MethodBlock :: BlockType
lookupLocalVariableFromST :: Name -> SymbolTable -> Maybe (Either Argument FieldDecl)
lookupLocalMethodFromST :: Name -> SymbolTable -> Maybe (Either ImportDecl MethodDecl)
instance GHC.Classes.Eq Semantic.BlockType
instance GHC.Show.Show Semantic.BlockType
instance GHC.Generics.Generic Semantic.SymbolTable
instance GHC.Generics.Generic Semantic.SemanticState
instance GHC.Show.Show Semantic.SemanticState
instance GHC.Generics.Generic Semantic.SemanticInfo
instance GHC.Show.Show Semantic.SemanticInfo
instance Control.Monad.State.Class.MonadState Semantic.SemanticState Semantic.Semantic
instance Control.Monad.Writer.Class.MonadWriter [Semantic.SemanticError] Semantic.Semantic
instance Control.Monad.Error.Class.MonadError Semantic.SemanticException Semantic.Semantic
instance GHC.Base.Monad Semantic.Semantic
instance GHC.Base.Applicative Semantic.Semantic
instance GHC.Base.Functor Semantic.Semantic
instance GHC.Show.Show Semantic.SymbolTable
instance GHC.Show.Show Semantic.SemanticException
instance GHC.Show.Show Semantic.SemanticError

module SSA
data Locality
Global :: Locality
Local :: Locality
data Var
Var :: !VID -> !Type -> !Maybe (Either Argument FieldDecl) -> !Range -> !Locality -> Var
[$sel:id:Var] :: Var -> !VID
[$sel:tpe:Var] :: Var -> !Type
[$sel:astDecl:Var] :: Var -> !Maybe (Either Argument FieldDecl)
[$sel:loc:Var] :: Var -> !Range
[$sel:locality:Var] :: Var -> !Locality
type VarList = [Var]
type Label = Text
data VarOrImm
BoolImm :: !Bool -> VarOrImm
IntImm :: !Int64 -> VarOrImm
CharImm :: !Char -> VarOrImm
StringImm :: !Text -> VarOrImm
Variable :: !Var -> VarOrImm
data SSA
Assignment :: !Var -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:src:Assignment] :: SSA -> !VarOrImm
MethodCall :: !Var -> !Name -> ![Var] -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:name:Assignment] :: SSA -> !Name
[$sel:arguments:Assignment] :: SSA -> ![Var]
Return :: !Var -> SSA
[$sel:ret:Assignment] :: SSA -> !Var
Alloca :: !Var -> !Type -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:tpe:Assignment] :: SSA -> !Type
Load :: !Var -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:ptr:Assignment] :: SSA -> !VarOrImm
Store :: !VarOrImm -> !VarOrImm -> SSA
[$sel:ptr:Assignment] :: SSA -> !VarOrImm
[$sel:src:Assignment] :: SSA -> !VarOrImm
Arith :: !Var -> !ArithOp -> !VarOrImm -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:arithOp:Assignment] :: SSA -> !ArithOp
[$sel:opl:Assignment] :: SSA -> !VarOrImm
[$sel:opr:Assignment] :: SSA -> !VarOrImm
Rel :: !Var -> !RelOp -> !VarOrImm -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:relOp:Assignment] :: SSA -> !RelOp
[$sel:opl:Assignment] :: SSA -> !VarOrImm
[$sel:opr:Assignment] :: SSA -> !VarOrImm
Cond :: !Var -> !CondOp -> !VarOrImm -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:condOp:Assignment] :: SSA -> !CondOp
[$sel:opl:Assignment] :: SSA -> !VarOrImm
[$sel:opr:Assignment] :: SSA -> !VarOrImm
Eq :: !Var -> !EqOp -> !VarOrImm -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:eqOp:Assignment] :: SSA -> !EqOp
[$sel:opl:Assignment] :: SSA -> !VarOrImm
[$sel:opr:Assignment] :: SSA -> !VarOrImm
Neg :: !Var -> !NegOp -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:negOp:Assignment] :: SSA -> !NegOp
[$sel:oprand:Assignment] :: SSA -> !VarOrImm
Not :: !Var -> !NotOp -> !VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:notOp:Assignment] :: SSA -> !NotOp
[$sel:oprand:Assignment] :: SSA -> !VarOrImm
Phi :: !Var -> ![(Var, BBID)] -> SSA
[$sel:dst:Assignment] :: SSA -> !Var
[$sel:predecessors:Assignment] :: SSA -> ![(Var, BBID)]
BrUncon :: !Label -> SSA
[$sel:target:Assignment] :: SSA -> !Label
BrCon :: !VarOrImm -> !Label -> !Label -> SSA
[$sel:pred:Assignment] :: SSA -> !VarOrImm
[$sel:targetT:Assignment] :: SSA -> !Label
[$sel:targetF:Assignment] :: SSA -> !Label
ppVarWithType :: Format r (Var -> r)
ppVars :: Format r ([Var] -> r)
ppPhiPreds :: Format r ([(Var, BBID)] -> r)
instance GHC.Generics.Generic SSA.Var
instance GHC.Generics.Generic SSA.SSA
instance GHC.Show.Show SSA.SSA
instance GHC.Show.Show SSA.VarOrImm
instance GHC.Show.Show SSA.Var

module CFG
data Condition
Pred :: !VarOrImm -> Condition
[$sel:pred:Pred] :: Condition -> !VarOrImm
Complement :: Condition
data BasicBlock
BasicBlock :: !BBID -> !ScopeID -> ![SSA] -> BasicBlock
[$sel:bbid:BasicBlock] :: BasicBlock -> !BBID
[$sel:sid:BasicBlock] :: BasicBlock -> !ScopeID
[$sel:statements:BasicBlock] :: BasicBlock -> ![SSA]
newtype CFGNode
CFGNode :: BasicBlock -> CFGNode
[$sel:bb:CFGNode] :: CFGNode -> BasicBlock
data CFGEdge
SeqEdge :: CFGEdge
CondEdge :: !Condition -> CFGEdge
type CFG = Graph BBID CFGNode CFGEdge
type CFGBuilder = GraphBuilder BBID CFGNode CFGEdge
data SymVarMap
SymVarMap :: !Map Name VID -> !Maybe ScopeID -> SymVarMap
[$sel:m:SymVarMap] :: SymVarMap -> !Map Name VID
[$sel:parent:SymVarMap] :: SymVarMap -> !Maybe ScopeID
data CFGState
CFGState :: !CFG -> !ScopeID -> !MethodSig -> !BBID -> !VarList -> !Map ScopeID SymVarMap -> !Map VID (ScopeID, Name) -> ![SSA] -> !Maybe (BBID, BBID) -> !Maybe BBID -> !Map BBID (Map (ScopeID, Name) Var) -> CFGState
[$sel:cfg:CFGState] :: CFGState -> !CFG
[$sel:astScope:CFGState] :: CFGState -> !ScopeID
[$sel:sig:CFGState] :: CFGState -> !MethodSig
[$sel:currentBBID:CFGState] :: CFGState -> !BBID
[$sel:vars:CFGState] :: CFGState -> !VarList
[$sel:sym2var:CFGState] :: CFGState -> !Map ScopeID SymVarMap
[$sel:var2sym:CFGState] :: CFGState -> !Map VID (ScopeID, Name)
[$sel:statements:CFGState] :: CFGState -> ![SSA]
[$sel:currentControlBlock:CFGState] :: CFGState -> !Maybe (BBID, BBID)
[$sel:currentFunctionTail:CFGState] :: CFGState -> !Maybe BBID
[$sel:varWrite:CFGState] :: CFGState -> !Map BBID (Map (ScopeID, Name) Var)
data BBTransition
StayIn :: !BBID -> BBTransition
TailAt :: !BBID -> BBTransition
Deadend :: BBTransition
initialState :: MethodSig -> CFGState
updateCFG :: GraphBuilder BBID CFGNode CFGEdge a -> CFGBuild ()
data CFGContext
CFGContext :: SemanticInfo -> CFGContext
[$sel:semantic:CFGContext] :: CFGContext -> SemanticInfo
newtype CFGExcept
CFGExcept :: Text -> CFGExcept
newtype CFGBuild a
CFGBuild :: ExceptT CFGExcept (ReaderT CFGContext (State CFGState)) a -> CFGBuild a
[$sel:runCFGBuild:CFGBuild] :: CFGBuild a -> ExceptT CFGExcept (ReaderT CFGContext (State CFGState)) a
setASTScope :: ScopeID -> CFGBuild ()
setControlBlock :: Maybe (BBID, BBID) -> CFGBuild ()
getControlBlock :: CFGBuild (Maybe (BBID, BBID))
getControlEntry :: CFGBuild (Maybe BBID)
getControlExit :: CFGBuild (Maybe BBID)
setFunctionTail :: Maybe BBID -> CFGBuild ()
getFunctionTail :: CFGBuild (Maybe BBID)
getBasicBlock' :: BBID -> CFGBuild BasicBlock
addVarSym :: Name -> VID -> CFGBuild ()
lookupVar :: VID -> CFGBuild (Maybe (ScopeID, Name))
lookupVar' :: VID -> CFGBuild (ScopeID, Name)
lookupSymInScope :: Name -> ScopeID -> CFGBuild (Maybe Var)
lookupSymInScope' :: Name -> ScopeID -> CFGBuild Var
lookupSym :: Name -> CFGBuild (Maybe Var)
lookupSym' :: Name -> CFGBuild Var
getSymDecl :: Name -> CFGBuild (Maybe (Either Argument FieldDecl))
getSymScope :: Name -> CFGBuild (Maybe ScopeID)
createEmptyBB :: CFGBuild BBID
finishCurrentBB :: CFGBuild BBID
checkStmts :: CFGBuild ()
removeEmptySeqNode :: CFGBuild ()
newVar :: Maybe Name -> Type -> Range -> Locality -> CFGBuild Var
newLocal :: Maybe Name -> Type -> Range -> CFGBuild Var
newGlobal :: Name -> Type -> Range -> CFGBuild Var
addSSA :: SSA -> CFGBuild ()
buildCFG :: ASTRoot -> CFGContext -> Either CFGExcept (Map Name CFG)
populateGlobals :: ASTRoot -> CFGBuild ()
buildMethod :: MethodDecl -> CFGBuild CFG
buildBlock :: Block -> CFGBuild (BBID, BBID)
findOuterScopes :: ScopeID -> Map ScopeID SymbolTable -> Set ScopeID
inferPhiList :: [ScopeID] -> Set ScopeID -> CFGBuild [(ScopeID, Name)]
addDummyPhiNode :: [(ScopeID, Name)] -> CFGBuild ()
recordPhiVar :: [(ScopeID, Name)] -> CFGBuild (Map (ScopeID, Name) Var)
patchPhiNode :: BBID -> BBID -> Map (ScopeID, Name) Var -> BBID -> Map (ScopeID, Name) Var -> CFGBuild ()
buildAssignOp :: Var -> AssignOp -> Maybe Expr -> CFGBuild Var
buildStatement :: Statement -> CFGBuild BBTransition
buildExpr :: Expr -> CFGBuild Var
buildReadFromLocation :: Location -> CFGBuild Var
recordVarWrite :: Var -> ScopeID -> Name -> CFGBuild ()
buildWriteToLocation :: Location -> VarOrImm -> CFGBuild ()
buildMethodCall :: MethodCall -> Type -> CFGBuild Var
prettyPrintNode :: CFGNode -> Text
escape :: Text -> Text
prettyPrintEdge :: CFGEdge -> Text
generateDotPlot :: Graph BBID CFGNode CFGEdge -> Text
plot :: ASTRoot -> SemanticInfo -> Either [String] String
instance GHC.Show.Show CFG.Condition
instance GHC.Show.Show CFG.BasicBlock
instance GHC.Generics.Generic CFG.BasicBlock
instance GHC.Show.Show CFG.CFGNode
instance GHC.Generics.Generic CFG.CFGNode
instance GHC.Show.Show CFG.CFGEdge
instance GHC.Generics.Generic CFG.SymVarMap
instance GHC.Show.Show CFG.SymVarMap
instance GHC.Generics.Generic CFG.CFGState
instance GHC.Generics.Generic CFG.CFGContext
instance GHC.Show.Show CFG.CFGExcept
instance Control.Monad.State.Class.MonadState CFG.CFGState CFG.CFGBuild
instance Control.Monad.Reader.Class.MonadReader CFG.CFGContext CFG.CFGBuild
instance Control.Monad.Error.Class.MonadError CFG.CFGExcept CFG.CFGBuild
instance GHC.Base.Monad CFG.CFGBuild
instance GHC.Base.Applicative CFG.CFGBuild
instance GHC.Base.Functor CFG.CFGBuild
