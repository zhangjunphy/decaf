-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/zhangjunphy/decaf#README.md</a>
@package decaf
@version 0.1.0.0

module CodeGen

module Configuration.Types
data Configuration
Configuration :: FilePath -> Maybe CompilerStage -> Bool -> OptimizationSpecification -> Maybe FilePath -> Configuration
[$sel:input:Configuration] :: Configuration -> FilePath
[$sel:explicitTarget:Configuration] :: Configuration -> Maybe CompilerStage
[$sel:debug:Configuration] :: Configuration -> Bool
[$sel:opt:Configuration] :: Configuration -> OptimizationSpecification
[$sel:outputFileName:Configuration] :: Configuration -> Maybe FilePath
defaultConfiguration :: Configuration
data CompilerStage
Scan :: CompilerStage
Parse :: CompilerStage
Cfg :: CompilerStage
Inter :: CompilerStage
Assembly :: CompilerStage
data OptimizationSpecification
All :: OptimizationSpecification
Some :: [OptimizationName] -> OptimizationSpecification
data OptimizationName
Enable :: String -> OptimizationName
Disable :: String -> OptimizationName
instance GHC.Classes.Ord Configuration.Types.CompilerStage
instance GHC.Classes.Eq Configuration.Types.CompilerStage
instance GHC.Classes.Eq Configuration.Types.OptimizationName
instance GHC.Classes.Eq Configuration.Types.OptimizationSpecification
instance GHC.Classes.Eq Configuration.Types.Configuration
instance GHC.Show.Show Configuration.Types.CompilerStage
instance GHC.Read.Read Configuration.Types.CompilerStage

module Configuration
data Configuration
($sel:input:Configuration) :: Configuration -> FilePath
target :: Configuration -> CompilerStage
($sel:debug:Configuration) :: Configuration -> Bool
($sel:opt:Configuration) :: Configuration -> OptimizationSpecification
($sel:outputFileName:Configuration) :: Configuration -> Maybe FilePath
defaultConfiguration :: Configuration
data CompilerStage
Scan :: CompilerStage
Parse :: CompilerStage
Cfg :: CompilerStage
Inter :: CompilerStage
Assembly :: CompilerStage
data OptimizationSpecification
All :: OptimizationSpecification
Some :: [OptimizationName] -> OptimizationSpecification
data OptimizationName
Enable :: String -> OptimizationName
Disable :: String -> OptimizationName

module CLI
generateUsage :: IO String

-- | Parses command-line options, returning a <a>Configuration</a>
--   describing the behavior of the compiler.
getConfiguration :: IO (Either String Configuration)

module Constants
globalScopeID :: Int
topLevelLabel :: Text
mainMethodName :: Text

module DominatorTree

module Graph
newtype Node a
Node :: a -> Node a
data Graph ni nd ed
Graph :: Map (Node ni) nd -> Map (Node ni) [(Node ni, ed)] -> Graph ni nd ed
[$sel:nodes:Graph] :: Graph ni nd ed -> Map (Node ni) nd
[$sel:edges:Graph] :: Graph ni nd ed -> Map (Node ni) [(Node ni, ed)]
type GraphException = Text
empty :: Graph ni nd ed
outBound :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> [(Node ni, ed)]
inBound :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> [(Node ni, ed)]
lookupNode :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> Maybe nd
updateNodeWith :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> (Maybe nd -> nd) -> Graph ni nd ed
updateNode :: (Eq ni, Ord ni) => ni -> nd -> Graph ni nd ed -> Graph ni nd ed
union :: (Eq ni, Ord ni) => Graph ni nd ed -> Graph ni nd ed -> Graph ni nd ed
newtype GraphBuilder ni nd ed a
GraphBuilder :: ExceptT GraphException (State (Graph ni nd ed)) a -> GraphBuilder ni nd ed a
[$sel:buildGraph:GraphBuilder] :: GraphBuilder ni nd ed a -> ExceptT GraphException (State (Graph ni nd ed)) a
addNode :: (Eq ni, Ord ni) => ni -> nd -> GraphBuilder ni nd ed ni
addEdge :: (Eq ni, Ord ni) => ni -> ni -> ed -> GraphBuilder ni nd ed ()
deleteNode :: (Eq ni, Ord ni) => ni -> GraphBuilder ni nd ed ()
deleteEdge :: (Eq ni, Ord ni) => ni -> ni -> GraphBuilder ni nd ed ()
update :: (Eq ni, Ord ni) => GraphBuilder ni nd ed a -> Graph ni nd ed -> Either Text (Graph ni nd ed)
build :: (Eq ni, Ord ni) => GraphBuilder ni nd ed a -> Either Text (Graph ni nd ed)
instance GHC.Show.Show a => GHC.Show.Show (Graph.Node a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Graph.Node a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Graph.Node a)
instance (GHC.Show.Show ni, GHC.Show.Show nd, GHC.Show.Show ed) => GHC.Show.Show (Graph.Graph ni nd ed)
instance Control.Monad.State.Class.MonadState (Graph.Graph ni nd ed) (Graph.GraphBuilder ni nd ed)
instance Control.Monad.Error.Class.MonadError Graph.GraphException (Graph.GraphBuilder ni nd ed)
instance GHC.Base.Monad (Graph.GraphBuilder ni nd ed)
instance GHC.Base.Applicative (Graph.GraphBuilder ni nd ed)
instance GHC.Base.Functor (Graph.GraphBuilder ni nd ed)

module SourceLoc
data Posn
Posn :: !Int -> !Int -> !Int -> Posn
[$sel:offset:Posn] :: Posn -> !Int
[$sel:row:Posn] :: Posn -> !Int
[$sel:col:Posn] :: Posn -> !Int
data Range
Range :: Posn -> Posn -> Range
[$sel:start:Range] :: Range -> Posn
[$sel:stop:Range] :: Range -> Posn
data Located a
LocatedAt :: Range -> a -> Located a
unLocate :: Located a -> a
instance GHC.Classes.Ord SourceLoc.Posn
instance GHC.Classes.Eq SourceLoc.Posn
instance GHC.Classes.Ord SourceLoc.Range
instance GHC.Classes.Eq SourceLoc.Range
instance GHC.Base.Functor SourceLoc.Located
instance GHC.Show.Show a => GHC.Show.Show (SourceLoc.Located a)
instance GHC.Show.Show SourceLoc.Range
instance GHC.Show.Show SourceLoc.Posn

module Scanner

-- | A token.
data Token
Keyword :: Text -> Token
Identifier :: Text -> Token
CharLiteral :: Text -> Token
IntLiteral :: Text -> Token
BooleanLiteral :: Text -> Token
StringLiteral :: Text -> Token
AssignOp :: Token
CompoundAssignOp :: Text -> Token
IncrementOp :: Text -> Token
ArithmeticOp :: Text -> Token
RelationOp :: Text -> Token
EquationOp :: Text -> Token
ConditionOp :: Text -> Token
LCurly :: Token
RCurly :: Token
LParen :: Token
RParen :: Token
LBrack :: Token
RBrack :: Token
Choice :: Token
Colon :: Token
Semicolon :: Token
Comma :: Token
Negate :: Token
EOF :: Token
Error :: Text -> Token
newtype Alex a
Alex :: (AlexState -> Either String (AlexState, a)) -> Alex a
[$sel:unAlex:Alex] :: Alex a -> AlexState -> Either String (AlexState, a)
scan :: ByteString -> [Either String (Located Token)]
formatTokenOrError :: Either String (Located Token) -> Either String String
alexMonadScan :: Alex (Located Token)
runAlex :: ByteString -> Alex a -> Either String a
instance GHC.Classes.Ord Scanner.AlexPosn
instance GHC.Show.Show Scanner.AlexPosn
instance GHC.Classes.Eq Scanner.AlexPosn
instance GHC.Classes.Eq Scanner.Token
instance GHC.Base.Functor Scanner.Alex
instance GHC.Base.Applicative Scanner.Alex
instance GHC.Base.Monad Scanner.Alex
instance GHC.Show.Show Scanner.Token

module Parser
parse :: ByteString -> Either String Program
data Program
Program :: [Located ImportDecl] -> [Located FieldDecl] -> [Located MethodDecl] -> Program
[$sel:importDecls:Program] :: Program -> [Located ImportDecl]
[$sel:fieldDecls:Program] :: Program -> [Located FieldDecl]
[$sel:methodDecls:Program] :: Program -> [Located MethodDecl]
data ImportDecl
ImportDecl :: Text -> ImportDecl
[$sel:importId:ImportDecl] :: ImportDecl -> Text
data FieldDecl
FieldDecl :: Type -> [Located FieldElem] -> FieldDecl
[$sel:fieldType:FieldDecl] :: FieldDecl -> Type
[$sel:elems:FieldDecl] :: FieldDecl -> [Located FieldElem]
data MethodDecl
MethodDecl :: Text -> Maybe Type -> [Located Argument] -> Block -> MethodDecl
[$sel:methodId:MethodDecl] :: MethodDecl -> Text
[$sel:returnType:MethodDecl] :: MethodDecl -> Maybe Type
[$sel:arguments:MethodDecl] :: MethodDecl -> [Located Argument]
[$sel:block:MethodDecl] :: MethodDecl -> Block
data FieldElem
ScalarField :: Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
VectorField :: Text -> Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
[$sel:size:ScalarField] :: FieldElem -> Text
data Type
IntType :: Type
BoolType :: Type
data Argument
Argument :: Text -> Type -> Argument
[$sel:argumentId:Argument] :: Argument -> Text
[$sel:argumentType:Argument] :: Argument -> Type
data Block
Block :: [Located FieldDecl] -> [Located Statement] -> Block
[$sel:blockFieldDecls:Block] :: Block -> [Located FieldDecl]
[$sel:blockStatements:Block] :: Block -> [Located Statement]
data Statement
AssignStatement :: Location -> AssignExpr -> Statement
[$sel:assignLocation:AssignStatement] :: Statement -> Location
[$sel:assignExpr:AssignStatement] :: Statement -> AssignExpr
MethodCallStatement :: MethodCall -> Statement
[$sel:methodCallStatement:AssignStatement] :: Statement -> MethodCall
IfStatement :: Located Expr -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
IfElseStatement :: Located Expr -> Block -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
[$sel:elseBlock:AssignStatement] :: Statement -> Block
ForStatement :: Text -> Located Expr -> Located Expr -> CounterUpdate -> Block -> Statement
[$sel:counterId:AssignStatement] :: Statement -> Text
[$sel:counterExpr:AssignStatement] :: Statement -> Located Expr
[$sel:forPredExpr:AssignStatement] :: Statement -> Located Expr
[$sel:counterUpdate:AssignStatement] :: Statement -> CounterUpdate
[$sel:forBlock:AssignStatement] :: Statement -> Block
WhileStatement :: Located Expr -> Block -> Statement
[$sel:whileExpr:AssignStatement] :: Statement -> Located Expr
[$sel:whileBlock:AssignStatement] :: Statement -> Block
ReturnVoidStatement :: Statement
ReturnExprStatement :: Located Expr -> Statement
[$sel:returnExpr:AssignStatement] :: Statement -> Located Expr
BreakStatement :: Statement
ContinueStatement :: Statement
ErrorStatement :: Statement
data Location
ScalarLocation :: Text -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
VectorLocation :: Text -> Located Expr -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
[$sel:arrayIndexExpr:ScalarLocation] :: Location -> Located Expr
data AssignExpr
AssignExpr :: Text -> Located Expr -> AssignExpr
[$sel:assignOp:AssignExpr] :: AssignExpr -> Text
[$sel:assignSourceExpr:AssignExpr] :: AssignExpr -> Located Expr
IncrementExpr :: Text -> AssignExpr
[$sel:incrementOp:AssignExpr] :: AssignExpr -> Text
data MethodCall
MethodCall :: Text -> [Located ImportArg] -> MethodCall
[$sel:methodName:MethodCall] :: MethodCall -> Text
[$sel:importArguments:MethodCall] :: MethodCall -> [Located ImportArg]
data ImportArg
ExprImportArg :: Located Expr -> ImportArg
[$sel:argumentExpr:ExprImportArg] :: ImportArg -> Located Expr
StringImportArg :: Text -> ImportArg
[$sel:argumentString:ExprImportArg] :: ImportArg -> Text
data CounterUpdate
CounterUpdate :: Location -> AssignExpr -> CounterUpdate
[$sel:counterLocation:CounterUpdate] :: CounterUpdate -> Location
[$sel:updateExpr:CounterUpdate] :: CounterUpdate -> AssignExpr
data Expr
LocationExpr :: Location -> Expr
[$sel:location:LocationExpr] :: Expr -> Location
MethodCallExpr :: MethodCall -> Expr
[$sel:methodCallExpr:LocationExpr] :: Expr -> MethodCall
IntLiteralExpr :: Text -> Expr
[$sel:intLiteral:LocationExpr] :: Expr -> Text
CharLiteralExpr :: Text -> Expr
[$sel:charLiteral:LocationExpr] :: Expr -> Text
BoolLiteralExpr :: Text -> Expr
[$sel:boolLiteral:LocationExpr] :: Expr -> Text
LenExpr :: Text -> Expr
[$sel:lenId:LocationExpr] :: Expr -> Text
ArithOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:arithOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
RelOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:relOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
EqOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:eqOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
CondOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:condOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
NegativeExpr :: Located Expr -> Expr
[$sel:negativeExpr:LocationExpr] :: Expr -> Located Expr
NegateExpr :: Located Expr -> Expr
[$sel:negateExpr:LocationExpr] :: Expr -> Located Expr
ParenExpr :: Located Expr -> Expr
[$sel:parenExpr:LocationExpr] :: Expr -> Located Expr
ChoiceExpr :: Located Expr -> Located Expr -> Located Expr -> Expr
[$sel:choicePredExpr:LocationExpr] :: Expr -> Located Expr
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
instance GHC.Show.Show Parser.ImportDecl
instance GHC.Show.Show Parser.FieldElem
instance GHC.Show.Show Parser.Type
instance GHC.Show.Show Parser.FieldDecl
instance GHC.Show.Show Parser.Argument
instance GHC.Show.Show Parser.Location
instance GHC.Show.Show Parser.ImportArg
instance GHC.Show.Show Parser.MethodCall
instance GHC.Show.Show Parser.Expr
instance GHC.Show.Show Parser.AssignExpr
instance GHC.Show.Show Parser.CounterUpdate
instance GHC.Show.Show Parser.Block
instance GHC.Show.Show Parser.Statement
instance GHC.Show.Show Parser.MethodDecl
instance GHC.Show.Show Parser.Program

module AST
type Name = Text
type Index = Int64
type ScopeID = Int
data RelOp
LessThan :: RelOp
GreaterThan :: RelOp
LessEqual :: RelOp
GreaterEqual :: RelOp
data ArithOp
Plus :: ArithOp
Minus :: ArithOp
Multiply :: ArithOp
Division :: ArithOp
Modulo :: ArithOp
data EqOp
Equal :: EqOp
NotEqual :: EqOp
data CondOp
OR :: CondOp
AND :: CondOp
data NegOp
Neg :: NegOp
data NotOp
Not :: NotOp
data ChoiceOp
Choice :: ChoiceOp
data AssignOp
EqlAssign :: AssignOp
IncAssign :: AssignOp
DecAssign :: AssignOp
PlusPlus :: AssignOp
MinusMinus :: AssignOp
data Type
IntType :: Type
BoolType :: Type
StringType :: Type
ArrayType :: Type -> Int64 -> Type
parseArithOp :: Text -> ArithOp
parseRelOp :: Text -> RelOp
parseEqOp :: Text -> EqOp
parseCondOp :: Text -> CondOp
parseNegOp :: Text -> NegOp
parseNotOp :: Text -> NotOp
parseAssignOp :: Text -> AssignOp
data Location
Location :: Name -> Maybe Expr -> Either Argument FieldDecl -> Location
[$sel:name:Location] :: Location -> Name
[$sel:idx:Location] :: Location -> Maybe Expr
[$sel:variableDef:Location] :: Location -> Either Argument FieldDecl
typeOfDef :: Either Argument FieldDecl -> Type
data Assignment
Assignment :: Typed Location -> AssignOp -> Maybe (Located (Typed Expr)) -> Assignment
[$sel:location:Assignment] :: Assignment -> Typed Location
[$sel:op:Assignment] :: Assignment -> AssignOp
[$sel:expr:Assignment] :: Assignment -> Maybe (Located (Typed Expr))
data MethodCall
MethodCall :: Name -> [Located (Typed Expr)] -> MethodCall
[$sel:name:MethodCall] :: MethodCall -> Name
[$sel:args:MethodCall] :: MethodCall -> [Located (Typed Expr)]
data ASTRoot
ASTRoot :: [Located ImportDecl] -> [Located FieldDecl] -> [Located MethodDecl] -> ASTRoot
[$sel:imports:ASTRoot] :: ASTRoot -> [Located ImportDecl]
[$sel:vars:ASTRoot] :: ASTRoot -> [Located FieldDecl]
[$sel:methods:ASTRoot] :: ASTRoot -> [Located MethodDecl]
data ImportDecl
ImportDecl :: Name -> ImportDecl
[$sel:name:ImportDecl] :: ImportDecl -> Name
data FieldDecl
FieldDecl :: Name -> Type -> FieldDecl
[$sel:name:FieldDecl] :: FieldDecl -> Name
[$sel:tpe:FieldDecl] :: FieldDecl -> Type
data Argument
Argument :: Name -> Type -> Argument
[$sel:name:Argument] :: Argument -> Name
[$sel:tpe:Argument] :: Argument -> Type
data MethodSig
MethodSig :: Name -> Maybe Type -> [Located Argument] -> MethodSig
[$sel:name:MethodSig] :: MethodSig -> Name
[$sel:tpe:MethodSig] :: MethodSig -> Maybe Type
[$sel:args:MethodSig] :: MethodSig -> [Located Argument]
data MethodDecl
MethodDecl :: MethodSig -> Block -> MethodDecl
[$sel:sig:MethodDecl] :: MethodDecl -> MethodSig
[$sel:block:MethodDecl] :: MethodDecl -> Block
data Statement
AssignStmt :: Assignment -> Statement
[$sel:assign:AssignStmt] :: Statement -> Assignment
IfStmt :: Located (Typed Expr) -> Block -> Maybe Block -> Statement
[$sel:pred:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:ifBlock:AssignStmt] :: Statement -> Block
[$sel:elseBlock:AssignStmt] :: Statement -> Maybe Block
ForStmt :: Name -> Located (Typed Expr) -> Located (Typed Expr) -> Assignment -> Block -> Statement
[$sel:counter:AssignStmt] :: Statement -> Name
[$sel:initCounter:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:pred:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:update:AssignStmt] :: Statement -> Assignment
[$sel:block:AssignStmt] :: Statement -> Block
WhileStmt :: Located (Typed Expr) -> Block -> Statement
[$sel:pred:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:block:AssignStmt] :: Statement -> Block
ReturnStmt :: Maybe (Located (Typed Expr)) -> Statement
[$sel:expr:AssignStmt] :: Statement -> Maybe (Located (Typed Expr))
MethodCallStmt :: MethodCall -> Statement
[$sel:methodCall:AssignStmt] :: Statement -> MethodCall
BreakStmt :: Statement
ContinueStmt :: Statement
VarDeclStmt :: FieldDecl -> Statement
[$sel:field:AssignStmt] :: Statement -> FieldDecl
data Expr
LocationExpr :: Location -> Expr
[$sel:location:LocationExpr] :: Expr -> Location
MethodCallExpr :: MethodCall -> Expr
[$sel:methodCall:LocationExpr] :: Expr -> MethodCall
ExternCallExpr :: Name -> [Located (Typed Expr)] -> Expr
[$sel:name:LocationExpr] :: Expr -> Name
[$sel:args:LocationExpr] :: Expr -> [Located (Typed Expr)]
IntLiteralExpr :: Int64 -> Expr
[$sel:intVal:LocationExpr] :: Expr -> Int64
BoolLiteralExpr :: Bool -> Expr
[$sel:boolVal:LocationExpr] :: Expr -> Bool
CharLiteralExpr :: Char -> Expr
[$sel:charVal:LocationExpr] :: Expr -> Char
StringLiteralExpr :: Text -> Expr
[$sel:strVal:LocationExpr] :: Expr -> Text
ArithOpExpr :: ArithOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:arithOp:LocationExpr] :: Expr -> ArithOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
RelOpExpr :: RelOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:relOp:LocationExpr] :: Expr -> RelOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
CondOpExpr :: CondOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:condOp:LocationExpr] :: Expr -> CondOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
EqOpExpr :: EqOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:eqOp:LocationExpr] :: Expr -> EqOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
NegOpExpr :: NegOp -> Located (Typed Expr) -> Expr
[$sel:negOp:LocationExpr] :: Expr -> NegOp
[$sel:expr:LocationExpr] :: Expr -> Located (Typed Expr)
NotOpExpr :: NotOp -> Located (Typed Expr) -> Expr
[$sel:notOp:LocationExpr] :: Expr -> NotOp
[$sel:expr:LocationExpr] :: Expr -> Located (Typed Expr)
ChoiceOpExpr :: ChoiceOp -> Located (Typed Expr) -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:choiceOp:LocationExpr] :: Expr -> ChoiceOp
[$sel:expr1:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:expr2:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:expr3:LocationExpr] :: Expr -> Located (Typed Expr)
LengthExpr :: Name -> Expr
[$sel:name:LocationExpr] :: Expr -> Name
data Typed a
Typed :: a -> Type -> Typed a
[$sel:ele:Typed] :: Typed a -> a
[$sel:tpe:Typed] :: Typed a -> Type
data Block
Block :: [Located FieldDecl] -> [Located Statement] -> ScopeID -> Block
[$sel:vars:Block] :: Block -> [Located FieldDecl]
[$sel:stmts:Block] :: Block -> [Located Statement]
[$sel:blockID:Block] :: Block -> ScopeID
instance GHC.Classes.Eq AST.RelOp
instance GHC.Show.Show AST.RelOp
instance GHC.Classes.Eq AST.ArithOp
instance GHC.Show.Show AST.ArithOp
instance GHC.Classes.Eq AST.EqOp
instance GHC.Show.Show AST.EqOp
instance GHC.Classes.Eq AST.CondOp
instance GHC.Show.Show AST.CondOp
instance GHC.Classes.Eq AST.NegOp
instance GHC.Show.Show AST.NegOp
instance GHC.Classes.Eq AST.NotOp
instance GHC.Show.Show AST.NotOp
instance GHC.Classes.Eq AST.ChoiceOp
instance GHC.Show.Show AST.ChoiceOp
instance GHC.Classes.Eq AST.AssignOp
instance GHC.Show.Show AST.AssignOp
instance GHC.Classes.Eq AST.Type
instance GHC.Show.Show AST.Type
instance GHC.Show.Show AST.ImportDecl
instance GHC.Generics.Generic AST.ImportDecl
instance GHC.Show.Show AST.FieldDecl
instance GHC.Generics.Generic AST.FieldDecl
instance GHC.Show.Show AST.Argument
instance GHC.Generics.Generic AST.Argument
instance GHC.Show.Show AST.MethodSig
instance GHC.Generics.Generic AST.MethodSig
instance GHC.Show.Show a => GHC.Show.Show (AST.Typed a)
instance GHC.Generics.Generic (AST.Typed a)
instance GHC.Show.Show AST.Expr
instance GHC.Generics.Generic AST.Expr
instance GHC.Show.Show AST.MethodCall
instance GHC.Generics.Generic AST.MethodCall
instance GHC.Show.Show AST.Assignment
instance GHC.Generics.Generic AST.Assignment
instance GHC.Show.Show AST.Statement
instance GHC.Generics.Generic AST.Statement
instance GHC.Show.Show AST.Block
instance GHC.Generics.Generic AST.Block
instance GHC.Show.Show AST.MethodDecl
instance GHC.Generics.Generic AST.MethodDecl
instance GHC.Show.Show AST.ASTRoot
instance GHC.Generics.Generic AST.ASTRoot
instance GHC.Show.Show AST.Location

module Semantic
runSemanticAnalysis :: Program -> Either String (ASTRoot, [SemanticError], Map ScopeID SymbolTable)
data SymbolTable
SymbolTable :: ScopeID -> Maybe SymbolTable -> Maybe (Map Name ImportDecl) -> Map Name FieldDecl -> Maybe (Map Name MethodDecl) -> BlockType -> Maybe MethodSig -> SymbolTable
[$sel:scopeID:SymbolTable] :: SymbolTable -> ScopeID
[$sel:parent:SymbolTable] :: SymbolTable -> Maybe SymbolTable
[$sel:importSymbols:SymbolTable] :: SymbolTable -> Maybe (Map Name ImportDecl)
[$sel:variableSymbols:SymbolTable] :: SymbolTable -> Map Name FieldDecl
[$sel:methodSymbols:SymbolTable] :: SymbolTable -> Maybe (Map Name MethodDecl)
[$sel:blockType:SymbolTable] :: SymbolTable -> BlockType
[$sel:methodSig:SymbolTable] :: SymbolTable -> Maybe MethodSig
type ScopeID = Int
data BlockType
RootBlock :: BlockType
IfBlock :: BlockType
ForBlock :: BlockType
WhileBlock :: BlockType
MethodBlock :: BlockType
lookupLocalVariableFromST :: Name -> SymbolTable -> Maybe MethodSig -> Maybe (Either Argument FieldDecl)
lookupLocalMethodFromST :: Name -> SymbolTable -> Maybe (Either ImportDecl MethodDecl)
instance GHC.Classes.Eq Semantic.BlockType
instance GHC.Show.Show Semantic.BlockType
instance GHC.Show.Show Semantic.SemanticState
instance Control.Monad.State.Class.MonadState Semantic.SemanticState Semantic.Semantic
instance Control.Monad.Writer.Class.MonadWriter [Semantic.SemanticError] Semantic.Semantic
instance Control.Monad.Error.Class.MonadError Semantic.SemanticException Semantic.Semantic
instance GHC.Base.Monad Semantic.Semantic
instance GHC.Base.Applicative Semantic.Semantic
instance GHC.Base.Functor Semantic.Semantic
instance GHC.Show.Show Semantic.SymbolTable
instance GHC.Show.Show Semantic.SemanticException
instance GHC.Show.Show Semantic.SemanticError

module SSA
type VID = Int
data Var
Var :: Type -> Maybe FieldDecl -> Maybe Range -> Var
[$sel:tpe:Var] :: Var -> Type
[$sel:astDecl:Var] :: Var -> Maybe FieldDecl
[$sel:loc:Var] :: Var -> Maybe Range
data VarOrImm
BoolImm :: Bool -> VarOrImm
IntImm :: Int -> VarOrImm
StringImm :: Text -> VarOrImm
Variable :: Var -> VarOrImm
type VarList = [Var]
data SSA
Assignment :: Var -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:src:Assignment] :: SSA -> VarOrImm
MethodCall :: Var -> [Var] -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:arguments:Assignment] :: SSA -> [Var]
Return :: Var -> SSA
[$sel:ret:Assignment] :: SSA -> Var
ArrayDeref :: Var -> Var -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:arr:Assignment] :: SSA -> Var
[$sel:idx:Assignment] :: SSA -> VarOrImm
Arith :: Var -> ArithOp -> VarOrImm -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:arithOp:Assignment] :: SSA -> ArithOp
[$sel:opl:Assignment] :: SSA -> VarOrImm
[$sel:opr:Assignment] :: SSA -> VarOrImm
Rel :: Var -> RelOp -> VarOrImm -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:relOp:Assignment] :: SSA -> RelOp
[$sel:opl:Assignment] :: SSA -> VarOrImm
[$sel:opr:Assignment] :: SSA -> VarOrImm
Cond :: Var -> CondOp -> VarOrImm -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:condOp:Assignment] :: SSA -> CondOp
[$sel:opl:Assignment] :: SSA -> VarOrImm
[$sel:opr:Assignment] :: SSA -> VarOrImm
Eq :: Var -> EqOp -> VarOrImm -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:eqOp:Assignment] :: SSA -> EqOp
[$sel:opl:Assignment] :: SSA -> VarOrImm
[$sel:opr:Assignment] :: SSA -> VarOrImm
Neg :: Var -> NegOp -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:negOp:Assignment] :: SSA -> NegOp
[$sel:oprand:Assignment] :: SSA -> VarOrImm
Not :: Var -> NotOp -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:notOp:Assignment] :: SSA -> NotOp
[$sel:oprand:Assignment] :: SSA -> VarOrImm
Choice :: Var -> ChoiceOp -> VarOrImm -> VarOrImm -> VarOrImm -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:choiceOp:Assignment] :: SSA -> ChoiceOp
[$sel:pred:Assignment] :: SSA -> VarOrImm
[$sel:opl:Assignment] :: SSA -> VarOrImm
[$sel:opr:Assignment] :: SSA -> VarOrImm
Len :: Var -> Var -> SSA
[$sel:dst:Assignment] :: SSA -> Var
[$sel:arr:Assignment] :: SSA -> Var
instance GHC.Show.Show SSA.Var
instance GHC.Show.Show SSA.VarOrImm
instance GHC.Show.Show SSA.SSA

module CFG
type Label = Text
type BBID = Int
type VID = Int
data Condition
Pred :: Typed Expr -> Condition
[$sel:pred:Pred] :: Condition -> Typed Expr
Complement :: Condition
data CFGContext
CFGContext :: Map ScopeID SymbolTable -> CFGContext
[$sel:symbolTables:CFGContext] :: CFGContext -> Map ScopeID SymbolTable
data BasicBlock
BasicBlock :: BBID -> ScopeID -> [Statement] -> BasicBlock
[$sel:bbid:BasicBlock] :: BasicBlock -> BBID
[$sel:sid:BasicBlock] :: BasicBlock -> ScopeID
[$sel:statements:BasicBlock] :: BasicBlock -> [Statement]
data CFGNode
CFGNode :: BasicBlock -> CFGNode
[$sel:bb:CFGNode] :: CFGNode -> BasicBlock
data CFGEdge
SeqEdge :: CFGEdge
CondEdge :: Condition -> CFGEdge
type CFG = Graph BBID CFGNode CFGEdge
type CFGBuilder = GraphBuilder BBID CFGNode CFGEdge
data CFGState
CFGState :: CFG -> ScopeID -> BBID -> [Statement] -> CFGState
[$sel:cfg:CFGState] :: CFGState -> CFG
[$sel:astScope:CFGState] :: CFGState -> ScopeID
[$sel:nextBBID:CFGState] :: CFGState -> BBID
[$sel:statements:CFGState] :: CFGState -> [Statement]
newtype CFGExcept
CFGExcept :: Text -> CFGExcept
newtype CFGBuild a
CFGBuild :: ExceptT CFGExcept (ReaderT CFGContext (State CFGState)) a -> CFGBuild a
[$sel:runCFGBuild:CFGBuild] :: CFGBuild a -> ExceptT CFGExcept (ReaderT CFGContext (State CFGState)) a
initialCFGState :: ScopeID -> CFGState
buildCFG :: ASTRoot -> CFGContext -> Either CFGExcept (Map Name CFG)
consumeBBID :: CFGBuild BBID
updateCFG :: GraphBuilder BBID CFGNode CFGEdge a -> CFGBuild ()
appendStatement :: Statement -> CFGBuild ()
createIsolateBB :: CFGBuild BBID
checkStmts :: CFGBuild ()
removeEmptySeqNode :: CFGBuild ()
buildMethod :: MethodDecl -> CFGBuild CFG
buildBlock :: Block -> CFGBuild (BBID, BBID)
buildStatement :: BBID -> Located Statement -> CFGBuild BBID
prettyPrintNode :: CFGNode -> Text
escape :: Text -> Text
prettyPrintEdge :: CFGEdge -> Text
generateDotPlot :: Graph BBID CFGNode CFGEdge -> Text
plot :: ASTRoot -> Map ScopeID SymbolTable -> Either [String] String
instance GHC.Show.Show CFG.Condition
instance GHC.Show.Show CFG.BasicBlock
instance GHC.Generics.Generic CFG.BasicBlock
instance GHC.Show.Show CFG.CFGNode
instance GHC.Generics.Generic CFG.CFGNode
instance GHC.Show.Show CFG.CFGEdge
instance GHC.Show.Show CFG.CFGState
instance GHC.Generics.Generic CFG.CFGState
instance GHC.Show.Show CFG.CFGExcept
instance Control.Monad.State.Class.MonadState CFG.CFGState CFG.CFGBuild
instance Control.Monad.Reader.Class.MonadReader CFG.CFGContext CFG.CFGBuild
instance Control.Monad.Error.Class.MonadError CFG.CFGExcept CFG.CFGBuild
instance GHC.Base.Monad CFG.CFGBuild
instance GHC.Base.Applicative CFG.CFGBuild
instance GHC.Base.Functor CFG.CFGBuild
