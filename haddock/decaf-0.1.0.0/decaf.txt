-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/zhangjunphy/decaf#README.md</a>
@package decaf
@version 0.1.0.0

module CodeGen

module Configuration.Types
data Configuration
Configuration :: FilePath -> Maybe CompilerStage -> Bool -> OptimizationSpecification -> Maybe FilePath -> Configuration
[input] :: Configuration -> FilePath
[explicitTarget] :: Configuration -> Maybe CompilerStage
[debug] :: Configuration -> Bool
[opt] :: Configuration -> OptimizationSpecification
[outputFileName] :: Configuration -> Maybe FilePath
defaultConfiguration :: Configuration
data CompilerStage
Scan :: CompilerStage
Parse :: CompilerStage
Inter :: CompilerStage
Assembly :: CompilerStage
data OptimizationSpecification
All :: OptimizationSpecification
Some :: [OptimizationName] -> OptimizationSpecification
data OptimizationName
Enable :: String -> OptimizationName
Disable :: String -> OptimizationName
instance GHC.Classes.Ord Configuration.Types.CompilerStage
instance GHC.Classes.Eq Configuration.Types.CompilerStage
instance GHC.Classes.Eq Configuration.Types.OptimizationName
instance GHC.Classes.Eq Configuration.Types.OptimizationSpecification
instance GHC.Classes.Eq Configuration.Types.Configuration
instance GHC.Show.Show Configuration.Types.CompilerStage
instance GHC.Read.Read Configuration.Types.CompilerStage

module Configuration
data Configuration
input :: Configuration -> FilePath
target :: Configuration -> CompilerStage
debug :: Configuration -> Bool
opt :: Configuration -> OptimizationSpecification
outputFileName :: Configuration -> Maybe FilePath
defaultConfiguration :: Configuration
data CompilerStage
Scan :: CompilerStage
Parse :: CompilerStage
Inter :: CompilerStage
Assembly :: CompilerStage
data OptimizationSpecification
All :: OptimizationSpecification
Some :: [OptimizationName] -> OptimizationSpecification
data OptimizationName
Enable :: String -> OptimizationName
Disable :: String -> OptimizationName

module CLI
generateUsage :: IO String

-- | Parses command-line options, returning a <a>Configuration</a>
--   describing the behavior of the compiler.
getConfiguration :: IO (Either String Configuration)

module Constants
globalScopeID :: Int
topLevelLabel :: Text
mainMethodName :: Text

module DominatorTree

module Graph
newtype Node a
Node :: a -> Node a
data Graph ni nd ed
Graph :: Map (Node ni) nd -> Map (Node ni) [(Node ni, ed)] -> Maybe (Node ni) -> Graph ni nd ed
[$sel:nodes:Graph] :: Graph ni nd ed -> Map (Node ni) nd
[$sel:edges:Graph] :: Graph ni nd ed -> Map (Node ni) [(Node ni, ed)]
[$sel:start:Graph] :: Graph ni nd ed -> Maybe (Node ni)
type GraphException = Text
empty :: Graph ni nd ed
outBound :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> [(Node ni, ed)]
inBound :: (Eq ni, Ord ni) => ni -> Graph ni nd ed -> [(Node ni, ed)]
newtype GraphBuilder ni nd ed a
GraphBuilder :: ExceptT GraphException (State (Graph ni nd ed)) a -> GraphBuilder ni nd ed a
[$sel:buildGraph:GraphBuilder] :: GraphBuilder ni nd ed a -> ExceptT GraphException (State (Graph ni nd ed)) a
addNode :: (Eq ni, Ord ni) => ni -> nd -> GraphBuilder ni nd ed (Node ni)
addEdge :: (Eq ni, Ord ni) => Node ni -> Node ni -> ed -> GraphBuilder ni nd ed ()
deleteNode :: (Eq ni, Ord ni) => Node ni -> GraphBuilder ni nd ed ()
deleteEdge :: (Eq ni, Ord ni) => Node ni -> Node ni -> GraphBuilder ni nd ed ()
update :: (Eq ni, Ord ni) => GraphBuilder ni nd ed () -> Graph ni nd ed -> Either String (Graph ni nd ed)
build :: (Eq ni, Ord ni) => GraphBuilder ni nd ed () -> Either String (Graph ni nd ed)
instance GHC.Show.Show a => GHC.Show.Show (Graph.Node a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Graph.Node a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Graph.Node a)
instance (GHC.Show.Show ni, GHC.Show.Show nd, GHC.Show.Show ed) => GHC.Show.Show (Graph.Graph ni nd ed)
instance Control.Monad.State.Class.MonadState (Graph.Graph ni nd ed) (Graph.GraphBuilder ni nd ed)
instance Control.Monad.Error.Class.MonadError Graph.GraphException (Graph.GraphBuilder ni nd ed)
instance GHC.Base.Monad (Graph.GraphBuilder ni nd ed)
instance GHC.Base.Applicative (Graph.GraphBuilder ni nd ed)
instance GHC.Base.Functor (Graph.GraphBuilder ni nd ed)

module SSA

module SourceLoc
data Posn
Posn :: !Int -> !Int -> !Int -> Posn
[offset] :: Posn -> !Int
[row] :: Posn -> !Int
[col] :: Posn -> !Int
data Range
Range :: Posn -> Posn -> Range
[start] :: Range -> Posn
[stop] :: Range -> Posn
data Located a
LocatedAt :: Range -> a -> Located a
unLocate :: Located a -> a
instance GHC.Classes.Ord SourceLoc.Posn
instance GHC.Classes.Eq SourceLoc.Posn
instance GHC.Classes.Ord SourceLoc.Range
instance GHC.Classes.Eq SourceLoc.Range
instance GHC.Base.Functor SourceLoc.Located
instance GHC.Show.Show a => GHC.Show.Show (SourceLoc.Located a)
instance GHC.Show.Show SourceLoc.Range
instance GHC.Show.Show SourceLoc.Posn

module Scanner

-- | A token.
data Token
Keyword :: Text -> Token
Identifier :: Text -> Token
CharLiteral :: Text -> Token
IntLiteral :: Text -> Token
BooleanLiteral :: Text -> Token
StringLiteral :: Text -> Token
AssignOp :: Token
CompoundAssignOp :: Text -> Token
IncrementOp :: Text -> Token
ArithmeticOp :: Text -> Token
RelationOp :: Text -> Token
EquationOp :: Text -> Token
ConditionOp :: Text -> Token
LCurly :: Token
RCurly :: Token
LParen :: Token
RParen :: Token
LBrack :: Token
RBrack :: Token
Choice :: Token
Colon :: Token
Semicolon :: Token
Comma :: Token
Negate :: Token
EOF :: Token
Error :: Text -> Token
newtype Alex a
Alex :: (AlexState -> Either String (AlexState, a)) -> Alex a
[$sel:unAlex:Alex] :: Alex a -> AlexState -> Either String (AlexState, a)
scan :: ByteString -> [Either String (Located Token)]
formatTokenOrError :: Either String (Located Token) -> Either String String
alexMonadScan :: Alex (Located Token)
runAlex :: ByteString -> Alex a -> Either String a
instance GHC.Classes.Ord Scanner.AlexPosn
instance GHC.Show.Show Scanner.AlexPosn
instance GHC.Classes.Eq Scanner.AlexPosn
instance GHC.Classes.Eq Scanner.Token
instance GHC.Base.Functor Scanner.Alex
instance GHC.Base.Applicative Scanner.Alex
instance GHC.Base.Monad Scanner.Alex
instance GHC.Show.Show Scanner.Token

module Parser
parse :: ByteString -> Either String Program
data Program
Program :: [Located ImportDecl] -> [Located FieldDecl] -> [Located MethodDecl] -> Program
[$sel:importDecls:Program] :: Program -> [Located ImportDecl]
[$sel:fieldDecls:Program] :: Program -> [Located FieldDecl]
[$sel:methodDecls:Program] :: Program -> [Located MethodDecl]
data ImportDecl
ImportDecl :: Text -> ImportDecl
[$sel:importId:ImportDecl] :: ImportDecl -> Text
data FieldDecl
FieldDecl :: Type -> [Located FieldElem] -> FieldDecl
[$sel:fieldType:FieldDecl] :: FieldDecl -> Type
[$sel:elems:FieldDecl] :: FieldDecl -> [Located FieldElem]
data MethodDecl
MethodDecl :: Text -> Maybe Type -> [Located Argument] -> Block -> MethodDecl
[$sel:methodId:MethodDecl] :: MethodDecl -> Text
[$sel:returnType:MethodDecl] :: MethodDecl -> Maybe Type
[$sel:arguments:MethodDecl] :: MethodDecl -> [Located Argument]
[$sel:block:MethodDecl] :: MethodDecl -> Block
data FieldElem
ScalarField :: Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
VectorField :: Text -> Text -> FieldElem
[$sel:fieldId:ScalarField] :: FieldElem -> Text
[$sel:size:ScalarField] :: FieldElem -> Text
data Type
IntType :: Type
BoolType :: Type
data Argument
Argument :: Text -> Type -> Argument
[$sel:argumentId:Argument] :: Argument -> Text
[$sel:argumentType:Argument] :: Argument -> Type
data Block
Block :: [Located FieldDecl] -> [Located Statement] -> Block
[$sel:blockFieldDecls:Block] :: Block -> [Located FieldDecl]
[$sel:blockStatements:Block] :: Block -> [Located Statement]
data Statement
AssignStatement :: Location -> AssignExpr -> Statement
[$sel:assignLocation:AssignStatement] :: Statement -> Location
[$sel:assignExpr:AssignStatement] :: Statement -> AssignExpr
MethodCallStatement :: MethodCall -> Statement
[$sel:methodCallStatement:AssignStatement] :: Statement -> MethodCall
IfStatement :: Located Expr -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
IfElseStatement :: Located Expr -> Block -> Block -> Statement
[$sel:ifExpr:AssignStatement] :: Statement -> Located Expr
[$sel:ifBlock:AssignStatement] :: Statement -> Block
[$sel:elseBlock:AssignStatement] :: Statement -> Block
ForStatement :: Text -> Located Expr -> Located Expr -> CounterUpdate -> Block -> Statement
[$sel:counterId:AssignStatement] :: Statement -> Text
[$sel:counterExpr:AssignStatement] :: Statement -> Located Expr
[$sel:forPredExpr:AssignStatement] :: Statement -> Located Expr
[$sel:counterUpdate:AssignStatement] :: Statement -> CounterUpdate
[$sel:forBlock:AssignStatement] :: Statement -> Block
WhileStatement :: Located Expr -> Block -> Statement
[$sel:whileExpr:AssignStatement] :: Statement -> Located Expr
[$sel:whileBlock:AssignStatement] :: Statement -> Block
ReturnVoidStatement :: Statement
ReturnExprStatement :: Located Expr -> Statement
[$sel:returnExpr:AssignStatement] :: Statement -> Located Expr
BreakStatement :: Statement
ContinueStatement :: Statement
ErrorStatement :: Statement
data Location
ScalarLocation :: Text -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
VectorLocation :: Text -> Located Expr -> Location
[$sel:locationId:ScalarLocation] :: Location -> Text
[$sel:arrayIndexExpr:ScalarLocation] :: Location -> Located Expr
data AssignExpr
AssignExpr :: Text -> Located Expr -> AssignExpr
[$sel:assignOp:AssignExpr] :: AssignExpr -> Text
[$sel:assignSourceExpr:AssignExpr] :: AssignExpr -> Located Expr
IncrementExpr :: Text -> AssignExpr
[$sel:incrementOp:AssignExpr] :: AssignExpr -> Text
data MethodCall
MethodCall :: Text -> [Located ImportArg] -> MethodCall
[$sel:methodName:MethodCall] :: MethodCall -> Text
[$sel:importArguments:MethodCall] :: MethodCall -> [Located ImportArg]
data ImportArg
ExprImportArg :: Located Expr -> ImportArg
[$sel:argumentExpr:ExprImportArg] :: ImportArg -> Located Expr
StringImportArg :: Text -> ImportArg
[$sel:argumentString:ExprImportArg] :: ImportArg -> Text
data CounterUpdate
CounterUpdate :: Location -> AssignExpr -> CounterUpdate
[$sel:counterLocation:CounterUpdate] :: CounterUpdate -> Location
[$sel:updateExpr:CounterUpdate] :: CounterUpdate -> AssignExpr
data Expr
LocationExpr :: Location -> Expr
[$sel:location:LocationExpr] :: Expr -> Location
MethodCallExpr :: MethodCall -> Expr
[$sel:methodCallExpr:LocationExpr] :: Expr -> MethodCall
IntLiteralExpr :: Text -> Expr
[$sel:intLiteral:LocationExpr] :: Expr -> Text
CharLiteralExpr :: Text -> Expr
[$sel:charLiteral:LocationExpr] :: Expr -> Text
BoolLiteralExpr :: Text -> Expr
[$sel:boolLiteral:LocationExpr] :: Expr -> Text
LenExpr :: Text -> Expr
[$sel:lenId:LocationExpr] :: Expr -> Text
ArithOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:arithOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
RelOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:relOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
EqOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:eqOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
CondOpExpr :: Text -> Located Expr -> Located Expr -> Expr
[$sel:condOp:LocationExpr] :: Expr -> Text
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
NegativeExpr :: Located Expr -> Expr
[$sel:negativeExpr:LocationExpr] :: Expr -> Located Expr
NegateExpr :: Located Expr -> Expr
[$sel:negateExpr:LocationExpr] :: Expr -> Located Expr
ParenExpr :: Located Expr -> Expr
[$sel:parenExpr:LocationExpr] :: Expr -> Located Expr
ChoiceExpr :: Located Expr -> Located Expr -> Located Expr -> Expr
[$sel:choicePredExpr:LocationExpr] :: Expr -> Located Expr
[$sel:lExpr:LocationExpr] :: Expr -> Located Expr
[$sel:rExpr:LocationExpr] :: Expr -> Located Expr
instance GHC.Show.Show Parser.ImportDecl
instance GHC.Show.Show Parser.FieldElem
instance GHC.Show.Show Parser.Type
instance GHC.Show.Show Parser.FieldDecl
instance GHC.Show.Show Parser.Argument
instance GHC.Show.Show Parser.Location
instance GHC.Show.Show Parser.ImportArg
instance GHC.Show.Show Parser.MethodCall
instance GHC.Show.Show Parser.Expr
instance GHC.Show.Show Parser.AssignExpr
instance GHC.Show.Show Parser.CounterUpdate
instance GHC.Show.Show Parser.Block
instance GHC.Show.Show Parser.Statement
instance GHC.Show.Show Parser.MethodDecl
instance GHC.Show.Show Parser.Program

module AST
type Name = Text
type Index = Int64
type ScopeID = Int
data RelOp
LessThan :: RelOp
GreaterThan :: RelOp
LessEqual :: RelOp
GreaterEqual :: RelOp
data ArithOp
Plus :: ArithOp
Minus :: ArithOp
Multiply :: ArithOp
Division :: ArithOp
Modulo :: ArithOp
data EqOp
Equal :: EqOp
NotEqual :: EqOp
data CondOp
OR :: CondOp
AND :: CondOp
data NegOp
Neg :: NegOp
data NotOp
Not :: NotOp
data ChoiceOp
Choice :: ChoiceOp
data AssignOp
EqlAssign :: AssignOp
IncAssign :: AssignOp
DecAssign :: AssignOp
PlusPlus :: AssignOp
MinusMinus :: AssignOp
data Type
IntType :: Type
BoolType :: Type
StringType :: Type
ArrayType :: Type -> Int64 -> Type
parseArithOp :: Text -> ArithOp
parseRelOp :: Text -> RelOp
parseEqOp :: Text -> EqOp
parseCondOp :: Text -> CondOp
parseNegOp :: Text -> NegOp
parseNotOp :: Text -> NotOp
parseAssignOp :: Text -> AssignOp
data Location
Location :: Name -> Maybe Expr -> Either Argument FieldDecl -> Location
[$sel:name:Location] :: Location -> Name
[$sel:idx:Location] :: Location -> Maybe Expr
[$sel:variableDef:Location] :: Location -> Either Argument FieldDecl
typeOfDef :: Either Argument FieldDecl -> Type
data Assignment
Assignment :: Typed Location -> AssignOp -> Maybe (Located (Typed Expr)) -> Assignment
[$sel:location:Assignment] :: Assignment -> Typed Location
[$sel:op:Assignment] :: Assignment -> AssignOp
[$sel:expr:Assignment] :: Assignment -> Maybe (Located (Typed Expr))
data MethodCall
MethodCall :: Name -> [Located (Typed Expr)] -> MethodCall
[$sel:name:MethodCall] :: MethodCall -> Name
[$sel:args:MethodCall] :: MethodCall -> [Located (Typed Expr)]
data ASTRoot
ASTRoot :: [Located ImportDecl] -> [Located FieldDecl] -> [Located MethodDecl] -> ASTRoot
[$sel:imports:ASTRoot] :: ASTRoot -> [Located ImportDecl]
[$sel:vars:ASTRoot] :: ASTRoot -> [Located FieldDecl]
[$sel:methods:ASTRoot] :: ASTRoot -> [Located MethodDecl]
data ImportDecl
ImportDecl :: Name -> ImportDecl
[$sel:name:ImportDecl] :: ImportDecl -> Name
data FieldDecl
FieldDecl :: Name -> Type -> FieldDecl
[$sel:name:FieldDecl] :: FieldDecl -> Name
[$sel:tpe:FieldDecl] :: FieldDecl -> Type
data Argument
Argument :: Name -> Type -> Argument
[$sel:name:Argument] :: Argument -> Name
[$sel:tpe:Argument] :: Argument -> Type
data MethodSig
MethodSig :: Name -> Maybe Type -> [Located Argument] -> MethodSig
[$sel:name:MethodSig] :: MethodSig -> Name
[$sel:tpe:MethodSig] :: MethodSig -> Maybe Type
[$sel:args:MethodSig] :: MethodSig -> [Located Argument]
data MethodDecl
MethodDecl :: MethodSig -> Block -> MethodDecl
[$sel:sig:MethodDecl] :: MethodDecl -> MethodSig
[$sel:block:MethodDecl] :: MethodDecl -> Block
data Statement
AssignStmt :: Assignment -> Statement
[$sel:assign:AssignStmt] :: Statement -> Assignment
IfStmt :: Located (Typed Expr) -> Block -> Maybe Block -> Statement
[$sel:pred:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:ifBlock:AssignStmt] :: Statement -> Block
[$sel:elseBlock:AssignStmt] :: Statement -> Maybe Block
ForStmt :: Name -> Located (Typed Expr) -> Located (Typed Expr) -> Assignment -> Block -> Statement
[$sel:counter:AssignStmt] :: Statement -> Name
[$sel:initCounter:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:pred:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:update:AssignStmt] :: Statement -> Assignment
[$sel:block:AssignStmt] :: Statement -> Block
WhileStmt :: Located (Typed Expr) -> Block -> Statement
[$sel:pred:AssignStmt] :: Statement -> Located (Typed Expr)
[$sel:block:AssignStmt] :: Statement -> Block
ReturnStmt :: Maybe (Located (Typed Expr)) -> Statement
[$sel:expr:AssignStmt] :: Statement -> Maybe (Located (Typed Expr))
MethodCallStmt :: MethodCall -> Statement
[$sel:methodCall:AssignStmt] :: Statement -> MethodCall
BreakStmt :: Statement
ContinueStmt :: Statement
VarDeclStmt :: FieldDecl -> Statement
[$sel:field:AssignStmt] :: Statement -> FieldDecl
data Expr
LocationExpr :: Location -> Expr
[$sel:location:LocationExpr] :: Expr -> Location
MethodCallExpr :: MethodCall -> Expr
[$sel:methodCall:LocationExpr] :: Expr -> MethodCall
ExternCallExpr :: Name -> [Located (Typed Expr)] -> Expr
[$sel:name:LocationExpr] :: Expr -> Name
[$sel:args:LocationExpr] :: Expr -> [Located (Typed Expr)]
IntLiteralExpr :: Int64 -> Expr
[$sel:intVal:LocationExpr] :: Expr -> Int64
BoolLiteralExpr :: Bool -> Expr
[$sel:boolVal:LocationExpr] :: Expr -> Bool
CharLiteralExpr :: Char -> Expr
[$sel:charVal:LocationExpr] :: Expr -> Char
StringLiteralExpr :: Text -> Expr
[$sel:strVal:LocationExpr] :: Expr -> Text
ArithOpExpr :: ArithOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:arithOp:LocationExpr] :: Expr -> ArithOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
RelOpExpr :: RelOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:relOp:LocationExpr] :: Expr -> RelOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
CondOpExpr :: CondOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:condOp:LocationExpr] :: Expr -> CondOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
EqOpExpr :: EqOp -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:eqOp:LocationExpr] :: Expr -> EqOp
[$sel:lhs:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:rhs:LocationExpr] :: Expr -> Located (Typed Expr)
NegOpExpr :: NegOp -> Located (Typed Expr) -> Expr
[$sel:negOp:LocationExpr] :: Expr -> NegOp
[$sel:expr:LocationExpr] :: Expr -> Located (Typed Expr)
NotOpExpr :: NotOp -> Located (Typed Expr) -> Expr
[$sel:notOp:LocationExpr] :: Expr -> NotOp
[$sel:expr:LocationExpr] :: Expr -> Located (Typed Expr)
ChoiceOpExpr :: ChoiceOp -> Located (Typed Expr) -> Located (Typed Expr) -> Located (Typed Expr) -> Expr
[$sel:choiceOp:LocationExpr] :: Expr -> ChoiceOp
[$sel:expr1:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:expr2:LocationExpr] :: Expr -> Located (Typed Expr)
[$sel:expr3:LocationExpr] :: Expr -> Located (Typed Expr)
LengthExpr :: Name -> Expr
[$sel:name:LocationExpr] :: Expr -> Name
data Typed a
Typed :: a -> Type -> Typed a
[$sel:ele:Typed] :: Typed a -> a
[$sel:tpe:Typed] :: Typed a -> Type
data Block
Block :: [Located FieldDecl] -> [Located Statement] -> ScopeID -> Block
[$sel:vars:Block] :: Block -> [Located FieldDecl]
[$sel:stmts:Block] :: Block -> [Located Statement]
[$sel:blockID:Block] :: Block -> ScopeID
instance GHC.Classes.Eq AST.RelOp
instance GHC.Show.Show AST.RelOp
instance GHC.Classes.Eq AST.ArithOp
instance GHC.Show.Show AST.ArithOp
instance GHC.Classes.Eq AST.EqOp
instance GHC.Show.Show AST.EqOp
instance GHC.Classes.Eq AST.CondOp
instance GHC.Show.Show AST.CondOp
instance GHC.Classes.Eq AST.NegOp
instance GHC.Show.Show AST.NegOp
instance GHC.Classes.Eq AST.NotOp
instance GHC.Show.Show AST.NotOp
instance GHC.Classes.Eq AST.ChoiceOp
instance GHC.Show.Show AST.ChoiceOp
instance GHC.Classes.Eq AST.AssignOp
instance GHC.Show.Show AST.AssignOp
instance GHC.Classes.Eq AST.Type
instance GHC.Show.Show AST.Type
instance GHC.Show.Show AST.ImportDecl
instance GHC.Generics.Generic AST.ImportDecl
instance GHC.Show.Show AST.FieldDecl
instance GHC.Generics.Generic AST.FieldDecl
instance GHC.Show.Show AST.Argument
instance GHC.Generics.Generic AST.Argument
instance GHC.Show.Show AST.MethodSig
instance GHC.Generics.Generic AST.MethodSig
instance GHC.Show.Show a => GHC.Show.Show (AST.Typed a)
instance GHC.Generics.Generic (AST.Typed a)
instance GHC.Show.Show AST.Expr
instance GHC.Generics.Generic AST.Expr
instance GHC.Show.Show AST.MethodCall
instance GHC.Generics.Generic AST.MethodCall
instance GHC.Show.Show AST.Assignment
instance GHC.Generics.Generic AST.Assignment
instance GHC.Show.Show AST.Statement
instance GHC.Generics.Generic AST.Statement
instance GHC.Show.Show AST.Block
instance GHC.Generics.Generic AST.Block
instance GHC.Show.Show AST.MethodDecl
instance GHC.Generics.Generic AST.MethodDecl
instance GHC.Show.Show AST.ASTRoot
instance GHC.Generics.Generic AST.ASTRoot
instance GHC.Show.Show AST.Location

module Semantic
runSemanticAnalysis :: Program -> Either String (ASTRoot, [SemanticError], Map ScopeID SymbolTable)
data SymbolTable
SymbolTable :: ScopeID -> Maybe SymbolTable -> Maybe (Map Name ImportDecl) -> Map Name FieldDecl -> Maybe (Map Name MethodDecl) -> BlockType -> Maybe MethodSig -> SymbolTable
[$sel:scopeID:SymbolTable] :: SymbolTable -> ScopeID
[$sel:parent:SymbolTable] :: SymbolTable -> Maybe SymbolTable
[$sel:importSymbols:SymbolTable] :: SymbolTable -> Maybe (Map Name ImportDecl)
[$sel:variableSymbols:SymbolTable] :: SymbolTable -> Map Name FieldDecl
[$sel:methodSymbols:SymbolTable] :: SymbolTable -> Maybe (Map Name MethodDecl)
[$sel:blockType:SymbolTable] :: SymbolTable -> BlockType
[$sel:methodSig:SymbolTable] :: SymbolTable -> Maybe MethodSig
type ScopeID = Int
data BlockType
RootBlock :: BlockType
IfBlock :: BlockType
ForBlock :: BlockType
WhileBlock :: BlockType
MethodBlock :: BlockType
lookupLocalVariableFromST :: Name -> SymbolTable -> Maybe MethodSig -> Maybe (Either Argument FieldDecl)
lookupLocalMethodFromST :: Name -> SymbolTable -> Maybe (Either ImportDecl MethodDecl)
instance GHC.Classes.Eq Semantic.BlockType
instance GHC.Show.Show Semantic.BlockType
instance GHC.Show.Show Semantic.SemanticState
instance Control.Monad.State.Class.MonadState Semantic.SemanticState Semantic.Semantic
instance Control.Monad.Writer.Class.MonadWriter [Semantic.SemanticError] Semantic.Semantic
instance Control.Monad.Error.Class.MonadError Semantic.SemanticException Semantic.Semantic
instance GHC.Base.Monad Semantic.Semantic
instance GHC.Base.Applicative Semantic.Semantic
instance GHC.Base.Functor Semantic.Semantic
instance GHC.Show.Show Semantic.SymbolTable
instance GHC.Show.Show Semantic.SemanticException
instance GHC.Show.Show Semantic.SemanticError

module CFG
type Label = Text
data Condition
Pred :: Expr -> Condition
[$sel:pred:Pred] :: Condition -> Expr
Complement :: Condition
data CFGContext
CFGContext :: Map ScopeID SymbolTable -> CFGContext
[$sel:symbolTables:CFGContext] :: CFGContext -> Map ScopeID SymbolTable
data CFGNodeData
StatementNode :: Statement -> CFGNodeData
data CFGEdgeData
SeqEdge :: CFGEdgeData
CondEdge :: Condition -> CFGEdgeData
data CFGState
CFGState :: Graph Int CFGNodeData CFGEdgeData -> ScopeID -> CFGState
[$sel:cfg:CFGState] :: CFGState -> Graph Int CFGNodeData CFGEdgeData
[$sel:sid:CFGState] :: CFGState -> ScopeID
newtype CFGExcept
CFGExcept :: Text -> CFGExcept
newtype CFGMonad a
CFGMonad :: ExceptT CFGExcept (ReaderT CFGContext (State CFGState)) a -> CFGMonad a
[$sel:runCFGMonad:CFGMonad] :: CFGMonad a -> ExceptT CFGExcept (ReaderT CFGContext (State CFGState)) a
instance GHC.Show.Show CFG.Condition
instance GHC.Show.Show CFG.CFGExcept
instance Control.Monad.State.Class.MonadState CFG.CFGState CFG.CFGMonad
instance Control.Monad.Reader.Class.MonadReader CFG.CFGContext CFG.CFGMonad
instance Control.Monad.Error.Class.MonadError CFG.CFGExcept CFG.CFGMonad
instance GHC.Base.Monad CFG.CFGMonad
instance GHC.Base.Applicative CFG.CFGMonad
instance GHC.Base.Functor CFG.CFGMonad
