-- Parser -- Decaf parser                                       -*- haskell -*-
-- Copyright (C) 2013  Benjamin Barenblat <bbaren@mit.edu>
--
-- This file is a part of decafc.
--
-- decafc is free software: you can redistribute it and/or modify it under the
-- terms of the MIT (X11) License as described in the LICENSE file.
--
-- decafc is distributed in the hope that it will be useful, but WITHOUT ANY
-- WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE.  See the X11 license for more details.
{
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}

module Parser ( parse
              , Program(..)
              , ImportDecl(..)
              , FieldDecl(..)
              , MethodDecl(..)
              , FieldElem(..)
              , Type(..)
              , Argument(..)
              , Block(..)
              , Statement(..)
              , Location(..)
              , AssignExpr(..)
              , MethodCall(..)
              , ImportArg(..)
              , CounterUpdate(..)
              , Expr(..)
              , Posn(..)
              , WithPos(..)
              ) where

import Text.Printf (printf)

import Scanner ( Token(..)
               , Alex(..)
               , AlexPosn(..)
               , runAlex
               , alexMonadScan
               , getLexerPosn
               , AlexState(..)
               )

import Data.ByteString.Lazy (ByteString)
import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString.Lazy.UTF8 as B (fromString, toString)
import qualified Data.ByteString.Lazy.Char8 as C8
}

--------------------------------- Directives ----------------------------------

%name parseInternal
%error { parseError }
%monad { Alex }
%lexer { lexerwrap } { EOF }
%tokentype { Token }

{-
Methods generated by Happy

parseInternal :: Alex Program
parseError :: Token -> Alex a
-}

%token
  id                { Identifier $$ }

  intLiteral        { IntLiteral $$ }
  stringLiteral     { StringLiteral $$ }
  boolLiteral       { BooleanLiteral $$ }
  charLiteral       { CharLiteral $$ }

  '{'               { LCurly }
  '}'               { RCurly }
  '['               { LBrack }
  ']'               { RBrack }
  '('               { LParen }
  ')'               { RParen }
  ';'               { Semicolon }
  '\:'              { Colon }
  ','               { Comma }
  '!'               { Negate }
  '?'               { Choice }

  import            { Keyword "import" }
  int               { Keyword "int" }
  bool              { Keyword "bool" }
  void              { Keyword "void" }
  if                { Keyword "if" }
  else              { Keyword "else" }
  for               { Keyword "for" }
  while             { Keyword "while" }
  return            { Keyword "return" }
  break             { Keyword "break" }
  continue          { Keyword "continue" }
  len               { Keyword "len" }

  '='               { AssignOp }
  '+'               { ArithmeticOp "+" }
  '-'               { ArithmeticOp "-" }
  '*'               { ArithmeticOp "*" }
  '/'               { ArithmeticOp "/" }
  '%'               { ArithmeticOp "%" }
  '<'               { RelationOp "<" }
  '<='              { RelationOp "<=" }
  '>'               { RelationOp ">" }
  '>='              { RelationOp ">=" }
  '=='              { EquationOp "==" }
  '!='              { EquationOp "!=" }
  '&&'              { ConditionOp "&&" }
  '||'              { ConditionOp "||" }
  incrementOp       { IncrementOp $$ }
  compoundAssignOp  { CompoundAssignOp $$ }


-- precedence --
%left '||'
%left '&&'
%nonassoc '==' '!='
%nonassoc '<' '<=' '>' '>='
%left '+' '-'
%left '*' '/' '%'
%left '!'
%left NEG

%% -------------------------------- Grammar -----------------------------------

Program : ImportDecls FieldDecls MethodDecls                { Program (reverse $1) (reverse $2) $3 }

ImportDecls : {- empty -}                                   { [] }
            | ImportDecls ImportDecl                        { $2 : $1 }
ImportDecl : import id ';'                                  {% insertPosn$ ImportDecl $2 }

FieldDecls : {- empty -}                                    { [] }
           | FieldDecls FieldDecl                           { $2 : $1 }
FieldDecl : int FieldList ';'                               {% insertPosn $ FieldDecl IntType (reverse $2) }
          | bool FieldList ';'                              {% insertPosn $ FieldDecl BoolType (reverse $2) }

FieldList : FieldElem                                       { [$1] }
          | FieldList ',' FieldElem                         { $3 : $1 }
FieldElem : id                                              {% insertPosn $ ScalarField $1 }
          | id '[' intLiteral ']'                           {% insertPosn $ VectorField $1 $3 }

MethodDecls : {- empty -}                                   { [] }
            | MethodDecl MethodDecls                        { $1 : $2 }
MethodDecl : int id '(' ArgumentList ')' Block              {% insertPosn $ MethodDecl $2 (Just IntType) (reverse $4) $6 }
           | bool id '(' ArgumentList ')' Block             {% insertPosn $ MethodDecl $2 (Just BoolType) (reverse $4) $6 }
           | void id '(' ArgumentList ')' Block             {% insertPosn $ MethodDecl $2 Nothing (reverse $4) $6 }
           | int id '(' ')' Block                           {% insertPosn $ MethodDecl $2 (Just IntType) [] $5 }
           | bool id '(' ')' Block                          {% insertPosn $ MethodDecl $2 (Just BoolType) [] $5 }
           | void id '(' ')' Block                          {% insertPosn $ MethodDecl $2 Nothing [] $5 }

ArgumentList : Argument                                     { [$1] }
             | ArgumentList ',' Argument                    { $3 : $1 }
Argument : int id                                           {% insertPosn $ Argument $2 IntType }
         | bool id                                          {% insertPosn $ Argument $2 BoolType }

Block : '{' FieldDecls Statements '}'                       { Block $2 (reverse $3) }

Statements : {- empty -}                                    { [] }
           | Statements Statement                           { $2 : $1 }

Statement : Location AssignExpr ';'                         {% insertPosn $ AssignStatement $1 $2 }
          | MethodCall ';'                                  {% insertPosn $ MethodCallStatement $1 }
          | if '(' Expr ')' Block                           {% insertPosn $ IfStatement $3 $5 }
          | if '(' Expr ')' Block else Block                {% insertPosn $ IfElseStatement $3 $5 $7 }
          | for '(' id '=' Expr ';' Expr ';' CounterUpdate ')' Block    {% insertPosn $ ForStatement $3 $5 $7 $9 $11 }
          | while '(' Expr ')' Block                        {% insertPosn $ WhileStatement $3 $5 }
          | return ';'                                      {% insertPosn $ ReturnVoidStatement }
          | return Expr ';'                                 {% insertPosn $ ReturnExprStatement $2 }
          | break ';'                                       {% insertPosn $ BreakStatement }
          | continue ';'                                    {% insertPosn $ ContinueStatement }

CounterUpdate : Location AssignExpr                         { CounterUpdate $1 $2 }

Location : id                                               { ScalarLocation $1 }
         | id '[' Expr ']'                                  { VectorLocation $1 $3 }

AssignExpr : AssignOp Expr                                  { AssignExpr $1 $2 }
           | incrementOp                                    { IncrementExpr $1 }

AssignOp : '='                                              { "=" }
         | compoundAssignOp                                 { $1 }

MethodCall : id '(' ImportArgs ')'                          { MethodCall $1 (reverse $3) }
           | id '(' ')'                                     { MethodCall $1 [] }

ImportArgs : ImportArg                                      { [$1] }
           | ImportArgs ',' ImportArg                       { $3 : $1 }

ImportArg : Expr                                            { ExprImportArg $1 }
          | stringLiteral                                   {% do
                                                                pos <- getPosn
                                                                return $ StringImportArg $ WithPos $1 pos
                                                            }

Expr : Expr1                                                { $1 }
     | Expr1 '?' Expr1 '\:' Expr                            {% insertPosn $ ChoiceExpr $1 $3 $5 }

Expr1 : Location                                            {% insertPosn $ LocationExpr $1 }
      | MethodCall                                          {% insertPosn $ MethodCallExpr $1 }
      | intLiteral                                          {% insertPosn $ IntLiteralExpr $1 }
      | charLiteral                                         {% insertPosn $ CharLiteralExpr $1 }
      | boolLiteral                                         {% insertPosn $ BoolLiteralExpr $1 }
      | len '(' id ')'                                      {% insertPosn $ LenExpr $3 }
      | Expr1 '+' Expr1                                     {% insertPosn $ ArithOpExpr "+" $1 $3 }
      | Expr1 '-' Expr1                                     {% insertPosn $ ArithOpExpr "-" $1 $3 }
      | Expr1 '*' Expr1                                     {% insertPosn $ ArithOpExpr "*" $1 $3 }
      | Expr1 '/' Expr1                                     {% insertPosn $ ArithOpExpr "/" $1 $3 }
      | Expr1 '%' Expr1                                     {% insertPosn $ ArithOpExpr "%" $1 $3 }
      | Expr1 '<' Expr1                                     {% insertPosn $ RelOpExpr "<" $1 $3 }
      | Expr1 '<=' Expr1                                    {% insertPosn $ RelOpExpr "<=" $1 $3 }
      | Expr1 '>' Expr1                                     {% insertPosn $ RelOpExpr ">" $1 $3 }
      | Expr1 '>=' Expr1                                    {% insertPosn $ RelOpExpr ">=" $1 $3 }
      | Expr1 '==' Expr1                                    {% insertPosn $ EqOpExpr "==" $1 $3 }
      | Expr1 '!=' Expr1                                    {% insertPosn $ EqOpExpr "!=" $1 $3 }
      | Expr1 '&&' Expr1                                    {% insertPosn $ CondOpExpr "&&" $1 $3 }
      | Expr1 '||' Expr1                                    {% insertPosn $ CondOpExpr "||" $1 $3 }
      | '-' Expr1 %prec NEG                                 {% insertPosn $ NegativeExpr $2 }
      | '!' Expr1                                           {% insertPosn $ NegateExpr $2 }
      | '(' Expr1 ')'                                       {% insertPosn $ ParenExpr $2 }

----------------------------------- Haskell -----------------------------------
{

lexerwrap :: (Token -> Alex a) -> Alex a
lexerwrap s = do
  token <- alexMonadScan
  s token

getPosn :: Alex Posn
getPosn = do
  (AlexPn _ row col) <- getLexerPosn
  return $ Posn row col

insertPosn :: a -> Alex (WithPos a)
insertPosn a = do
  pos <- getPosn
  return WithPos{unPos=a, getPos=pos}

data Posn = Posn { row :: Int
                 , col :: Int
                 } deriving (Show, Eq, Ord)

data WithPos a = WithPos { unPos :: a, getPos :: Posn }
                 deriving (Show)

data Program = Program { importDecls :: [WithPos ImportDecl]
                       , fieldDecls :: [WithPos FieldDecl]
                       , methodDecls :: [WithPos MethodDecl]
                       } deriving (Show)

data ImportDecl = ImportDecl { importId :: ByteString }
                  deriving (Show)

data FieldDecl = FieldDecl { fieldType :: Type
                           , elems:: [WithPos FieldElem]
                           } deriving (Show)

data FieldElem = ScalarField { fieldId :: ByteString }
               | VectorField { fieldId :: ByteString, size :: ByteString }
                 deriving (Show)

data Type = IntType | BoolType
            deriving (Show)

data MethodDecl = MethodDecl { methodId :: ByteString
                             , returnType :: Maybe Type
                             , arguments :: [WithPos Argument]
                             , block :: Block
                             } deriving (Show)

data Argument = Argument { argumentId :: ByteString
                         , argumentType :: Type
                         } deriving (Show)

data Block = Block { blockFieldDecls :: [WithPos FieldDecl]
                   , blockStatements :: [WithPos Statement]
                   } deriving (Show)

data Statement = AssignStatement { assignLocation :: Location, assignExpr :: AssignExpr }
               | MethodCallStatement { methodCallStatement :: MethodCall }
               | IfStatement { ifExpr :: WithPos Expr, ifBlock :: Block }
               | IfElseStatement { ifExpr :: WithPos Expr, ifBlock :: Block, elseBlock :: Block}
               | ForStatement { counterId :: ByteString, counterExpr :: WithPos Expr, forPredExpr :: WithPos Expr,
                                counterUpdate :: CounterUpdate, forBlock :: Block }
               | WhileStatement { whileExpr :: WithPos Expr, whileBlock :: Block }
               | ReturnVoidStatement
               | ReturnExprStatement { returnExpr :: WithPos Expr }
               | BreakStatement
               | ContinueStatement
               | ErrorStatement
                 deriving (Show)

data Location = ScalarLocation { locationId :: ByteString }
              | VectorLocation { locationId :: ByteString, arrayIndexExpr :: WithPos Expr }
                deriving (Show)

data AssignExpr = AssignExpr { assignOp :: ByteString, assignSourceExpr:: WithPos Expr }
                | IncrementExpr { incrementOp :: ByteString }
                  deriving (Show)

data MethodCall = MethodCall { methodName :: ByteString, importArguments :: [ImportArg] }
                  deriving (Show)

data ImportArg = ExprImportArg { argumentExpr :: WithPos Expr }
               | StringImportArg { argumentString :: WithPos ByteString }
                 deriving (Show)

data CounterUpdate = CounterUpdate { counterLocation :: Location, updateExpr :: AssignExpr }
                     deriving (Show)

data Expr = LocationExpr { location :: Location }
          | MethodCallExpr { methodCallExpr :: MethodCall }
          | IntLiteralExpr { intLiteral :: ByteString }
          | CharLiteralExpr { charLiteral :: ByteString }
          | BoolLiteralExpr { boolLiteral :: ByteString }
          | LenExpr { lenId :: ByteString }
          | ArithOpExpr { arithOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | RelOpExpr { relOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | EqOpExpr { eqOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | CondOpExpr { condOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | NegativeExpr { negativeExpr :: WithPos Expr }
          | NegateExpr { negateExpr :: WithPos Expr }
          | ParenExpr { parenExpr :: WithPos Expr }
          | ChoiceExpr { choicePredExpr :: WithPos Expr, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          deriving (Show)

parse :: ByteString -> Either String Program
parse input = runAlex input parseInternal

parseError :: Token -> Alex a
parseError tok = do
  (AlexPn _ line col) <- getLexerPosn
  Alex $ \_ -> Left $ printf "%d:%d: Error handling token '%s'" line col (show tok)
}
