-- Parser -- Decaf parser                                       -*- haskell -*-
-- Copyright (C) 2013  Benjamin Barenblat <bbaren@mit.edu>
--
-- This file is a part of decafc.
--
-- decafc is free software: you can redistribute it and/or modify it under the
-- terms of the MIT (X11) License as described in the LICENSE file.
--
-- decafc is distributed in the hope that it will be useful, but WITHOUT ANY
-- WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE.  See the X11 license for more details.
{
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}

module Parser ( parse
              , Program(..)
              , ImportDecl(..)
              , FieldDecl(..)
              , MethodDecl(..)
              , FieldElem(..)
              , Type(..)
              , Argument(..)
              , Block(..)
              , Statement(..)
              , Location(..)
              , AssignExpr(..)
              , MethodCall(..)
              , ImportArg(..)
              , CounterUpdate(..)
              , Expr(..)
              , Posn(..)
              , WithPos(..)
              ) where

import Text.Printf (printf)

import Scanner ( Token(..)
               , Alex(..)
               , AlexPosn(..)
               , runAlex
               , alexMonadScan
               , getLexerPosn
               )

import Data.ByteString.Lazy (ByteString)
import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString.Lazy.UTF8 as B (fromString, toString)
import qualified Data.ByteString.Lazy.Char8 as C8
}

--------------------------------- Directives ----------------------------------

%name parseInternal
%error { parseError }
%monad { Alex }
%lexer { lexerwrap } { EOF }
%tokentype { Token }

{-
Methods generated by happy

parseInternal :: Alex Program
parseError :: Token -> Alex a
-}

%token
  id                { Identifier $$ }

  intLiteral        { IntLiteral $$ }
  stringLiteral     { StringLiteral $$ }
  boolLiteral       { BooleanLiteral $$ }
  charLiteral       { CharLiteral $$ }

  '{'               { LCurly }
  '}'               { RCurly }
  '['               { LBrack }
  ']'               { RBrack }
  '('               { LParen }
  ')'               { RParen }
  ';'               { Semicolon }
  '\:'              { Colon }
  ','               { Comma }
  '!'               { Negate }
  '?'               { Choice }

  import            { Keyword "import" }
  int               { Keyword "int" }
  bool              { Keyword "bool" }
  void              { Keyword "void" }
  if                { Keyword "if" }
  else              { Keyword "else" }
  for               { Keyword "for" }
  while             { Keyword "while" }
  return            { Keyword "return" }
  break             { Keyword "break" }
  continue          { Keyword "continue" }
  len               { Keyword "len" }

  '='               { AssignOp }
  '+'               { ArithmeticOp "+" }
  '-'               { ArithmeticOp "-" }
  '*'               { ArithmeticOp "*" }
  '/'               { ArithmeticOp "/" }
  '%'               { ArithmeticOp "%" }
  '<'               { RelationOp "<" }
  '<='              { RelationOp "<=" }
  '>'               { RelationOp ">" }
  '>='              { RelationOp ">=" }
  '=='              { EquationOp "==" }
  '!='              { EquationOp "!=" }
  '&&'              { ConditionOp "&&" }
  '||'              { ConditionOp "||" }
  incrementOp       { IncrementOp $$ }
  compoundAssignOp  { CompoundAssignOp $$ }


-- precedence --
%left '||'
%left '&&'
%nonassoc '==' '!='
%nonassoc '<' '<=' '>' '>='
%left '+' '-'
%left '*' '/' '%'
%left '!'
%left NEG

%% -------------------------------- Grammar -----------------------------------

Program : ImportDecls FieldDecls MethodDecls                { Program (reverse $1) (reverse $2) $3 }

ImportDecls : {- empty -}                                   { [] }
            | ImportDecls ImportDecl                        { $2 : $1 }
ImportDecl : import pos id ';'                              { WithPos{unPos=ImportDecl $3, getPos=$2} }

FieldDecls : {- empty -}                                    { [] }
           | FieldDecls FieldDecl                           { $2 : $1 }
FieldDecl : pos int FieldList ';'                           { WithPos{unPos=FieldDecl IntType (reverse $3), getPos=$1} }
          | pos bool FieldList ';'                          { WithPos{unPos=FieldDecl BoolType (reverse $3), getPos=$1} }

FieldList : FieldElem                                       { [$1] }
          | FieldList ',' FieldElem                         { $3 : $1 }
FieldElem : pos id                                          { WithPos{unPos=ScalarField $2, getPos=$1} }
          | pos id '[' intLiteral ']'                       { WithPos{unPos=VectorField $2 $4, getPos=$1} }

MethodDecls : {- empty -}                                   { [] }
            | MethodDecl MethodDecls                        { $1 : $2 }
MethodDecl : pos int id '(' ArgumentList ')' Block          { WithPos{unPos=MethodDecl $3 (Just IntType) (reverse $5) $7, getPos=$1} }
           | pos bool id '(' ArgumentList ')' Block         { WithPos{unPos=MethodDecl $3 (Just BoolType) (reverse $5) $7, getPos=$1} }
           | pos void id '(' ArgumentList ')' Block         { WithPos{unPos=MethodDecl $3 Nothing (reverse $5) $7, getPos=$1} }
           | pos int id '(' ')' Block                       { WithPos{unPos=MethodDecl $3 (Just IntType) [] $6, getPos=$1} }
           | pos bool id '(' ')' Block                      { WithPos{unPos=MethodDecl $3 (Just BoolType) [] $6, getPos=$1} }
           | pos void id '(' ')' Block                      { WithPos{unPos=MethodDecl $3 Nothing [] $6, getPos=$1} }

ArgumentList : Argument                                     { [$1] }
             | ArgumentList ',' Argument                    { $3 : $1 }
Argument : pos int id                                       { WithPos{unPos=Argument $3 IntType, getPos=$1} }
         | pos bool id                                      { WithPos{unPos=Argument $3 BoolType, getPos=$1} }

Block : '{' FieldDecls Statements '}'                       { Block $2 (reverse $3) }

Statements : {- empty -}                                    { [] }
           | Statements Statement                           { $2 : $1 }

Statement : pos Location AssignExpr ';'                     { WithPos{unPos=AssignStatement $2 $3, getPos=$1} }
          | pos MethodCall ';'                              { WithPos{unPos=MethodCallStatement $2, getPos=$1} }
          | pos if '(' Expr ')' Block                       { WithPos{unPos=IfStatement $4 $6, getPos=$1} }
          | pos if '(' Expr ')' Block else Block            { WithPos{unPos=IfElseStatement $4 $6 $8, getPos=$1} }
          | pos for '(' id '=' Expr ';' Expr ';' CounterUpdate ')' Block    { WithPos{unPos=ForStatement $4 $6 $8 $10 $12, getPos=$1} }
          | pos while '(' Expr ')' Block                    { WithPos{unPos=WhileStatement $4 $6, getPos=$1} }
          | pos return ';'                                  { WithPos{unPos=ReturnVoidStatement, getPos=$1} }
          | pos return Expr ';'                             { WithPos{unPos=ReturnExprStatement $3, getPos=$1} }
          | pos break ';'                                   { WithPos{unPos=BreakStatement, getPos=$1} }
          | pos continue ';'                                { WithPos{unPos=ContinueStatement, getPos=$1} }

CounterUpdate : Location AssignExpr                         { CounterUpdate $1 $2 }

Location : id                                               { ScalarLocation $1 }
         | id '[' Expr ']'                                  { VectorLocation $1 $3 }

AssignExpr : AssignOp Expr                                  { AssignExpr $1 $2 }
           | incrementOp                                    { IncrementExpr $1 }

AssignOp : '='                                              { "=" }
         | compoundAssignOp                                 { $1 }

MethodCall : id '(' ImportArgs ')'                          { MethodCall $1 (reverse $3) }
           | id '(' ')'                                     { MethodCall $1 [] }

ImportArgs : ImportArg                                      { [$1] }
           | ImportArgs ',' ImportArg                       { $3 : $1 }

ImportArg : Expr                                            { ExprImportArg $1 }
          | pos stringLiteral                               { StringImportArg WithPos{unPos=$2, getPos=$1} }

Expr : Expr1                                                { $1 }
     | pos Expr1 '?' Expr1 '\:' Expr                        { WithPos{unPos=ChoiceExpr $2 $4 $6, getPos=$1} }

Expr1 : pos Location                                        { WithPos{unPos=LocationExpr $2, getPos=$1} }
      | pos MethodCall                                      { WithPos{unPos=MethodCallExpr $2, getPos=$1} }
      | pos intLiteral                                      { WithPos{unPos=IntLiteralExpr $2, getPos=$1} }
      | pos charLiteral                                     { WithPos{unPos=CharLiteralExpr $2, getPos=$1} }
      | pos boolLiteral                                     { WithPos{unPos=BoolLiteralExpr $2, getPos=$1} }
      | pos len '(' id ')'                                  { WithPos{unPos=LenExpr $4, getPos=$1} }
      | pos Expr1 '+' Expr1                                 { WithPos{unPos=ArithOpExpr "+" $2 $4, getPos=$1} }
      | pos Expr1 '-' Expr1                                 { WithPos{unPos=ArithOpExpr "-" $2 $4, getPos=$1} }
      | pos Expr1 '*' Expr1                                 { WithPos{unPos=ArithOpExpr "*" $2 $4, getPos=$1} }
      | pos Expr1 '/' Expr1                                 { WithPos{unPos=ArithOpExpr "/" $2 $4, getPos=$1} }
      | pos Expr1 '%' Expr1                                 { WithPos{unPos=ArithOpExpr "%" $2 $4, getPos=$1} }
      | pos Expr1 '<' Expr1                                 { WithPos{unPos=RelOpExpr "<" $2 $4, getPos=$1} }
      | pos Expr1 '<=' Expr1                                { WithPos{unPos=RelOpExpr "<=" $2 $4, getPos=$1} }
      | pos Expr1 '>' Expr1                                 { WithPos{unPos=RelOpExpr ">" $2 $4, getPos=$1} }
      | pos Expr1 '>=' Expr1                                { WithPos{unPos=RelOpExpr ">=" $2 $4, getPos=$1} }
      | pos Expr1 '==' Expr1                                { WithPos{unPos=EqOpExpr "==" $2 $4, getPos=$1} }
      | pos Expr1 '!=' Expr1                                { WithPos{unPos=EqOpExpr "!=" $2 $4, getPos=$1} }
      | pos Expr1 '&&' Expr1                                { WithPos{unPos=CondOpExpr "&&" $2 $4, getPos=$1} }
      | pos Expr1 '||' Expr1                                { WithPos{unPos=CondOpExpr "||" $2 $4, getPos=$1} }
      | pos '-' Expr1 %prec NEG                             { WithPos{unPos=NegativeExpr $3, getPos=$1} }
      | pos '!' Expr1                                       { WithPos{unPos=NegateExpr $3, getPos=$1} }
      | pos '(' Expr1 ')'                                   { WithPos{unPos=ParenExpr $3, getPos=$1} }

pos :: { Posn }
    : {- empty -}  {% getPosn }

----------------------------------- Haskell -----------------------------------
{

lexerwrap :: (Token -> Alex a) -> Alex a
lexerwrap s = do
  token <- alexMonadScan
  s token

getPosn :: Alex Posn
getPosn = do
  (AlexPn _ row col) <- getLexerPosn
  return $ Posn row col

data Posn = Posn { row :: Int
                 , col :: Int
                 } deriving (Show, Eq, Ord)

data WithPos a = WithPos { unPos :: a, getPos :: Posn }
                 deriving (Show)

data Program = Program { importDecls :: [WithPos ImportDecl]
                       , fieldDecls :: [WithPos FieldDecl]
                       , methodDecls :: [WithPos MethodDecl]
                       } deriving (Show)

data ImportDecl = ImportDecl { importId :: ByteString }
                  deriving (Show)

data FieldDecl = FieldDecl { fieldType :: Type
                           , elems:: [WithPos FieldElem]
                           } deriving (Show)

data FieldElem = ScalarField { fieldId :: ByteString }
               | VectorField { fieldId :: ByteString, size :: ByteString }
                 deriving (Show)

data Type = IntType | BoolType
            deriving (Show)

data MethodDecl = MethodDecl { methodId :: ByteString
                             , returnType :: Maybe Type
                             , arguments :: [WithPos Argument]
                             , block :: Block
                             } deriving (Show)

data Argument = Argument { argumentId :: ByteString
                         , argumentType :: Type
                         } deriving (Show)

data Block = Block { blockFieldDecls :: [WithPos FieldDecl]
                   , blockStatements :: [WithPos Statement]
                   } deriving (Show)

data Statement = AssignStatement { assignLocation :: Location, assignExpr :: AssignExpr }
               | MethodCallStatement { methodCallStatement :: MethodCall }
               | IfStatement { ifExpr :: WithPos Expr, ifBlock :: Block }
               | IfElseStatement { ifExpr :: WithPos Expr, ifBlock :: Block, elseBlock :: Block}
               | ForStatement { counterId :: ByteString, counterExpr :: WithPos Expr, forPredExpr :: WithPos Expr,
                                counterUpdate :: CounterUpdate, forBlock :: Block }
               | WhileStatement { whileExpr :: WithPos Expr, whileBlock :: Block }
               | ReturnVoidStatement
               | ReturnExprStatement { returnExpr :: WithPos Expr }
               | BreakStatement
               | ContinueStatement
               | ErrorStatement
                 deriving (Show)

data Location = ScalarLocation { locationId :: ByteString }
              | VectorLocation { locationId :: ByteString, arrayIndexExpr :: WithPos Expr }
                deriving (Show)

data AssignExpr = AssignExpr { assignOp :: ByteString, assignSourceExpr:: WithPos Expr }
                | IncrementExpr { incrementOp :: ByteString }
                  deriving (Show)

data MethodCall = MethodCall { methodName :: ByteString, importArguments :: [ImportArg] }
                  deriving (Show)

data ImportArg = ExprImportArg { argumentExpr :: WithPos Expr }
               | StringImportArg { argumentString :: WithPos ByteString }
                 deriving (Show)

data CounterUpdate = CounterUpdate { counterLocation :: Location, updateExpr :: AssignExpr }
                     deriving (Show)

data Expr = LocationExpr { location :: Location }
          | MethodCallExpr { methodCallExpr :: MethodCall }
          | IntLiteralExpr { intLiteral :: ByteString }
          | CharLiteralExpr { charLiteral :: ByteString }
          | BoolLiteralExpr { boolLiteral :: ByteString }
          | LenExpr { lenId :: ByteString }
          | ArithOpExpr { arithOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | RelOpExpr { relOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | EqOpExpr { eqOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | CondOpExpr { condOp :: ByteString, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          | NegativeExpr { negativeExpr :: WithPos Expr }
          | NegateExpr { negateExpr :: WithPos Expr }
          | ParenExpr { parenExpr :: WithPos Expr }
          | ChoiceExpr { choicePredExpr :: WithPos Expr, lExpr :: WithPos Expr, rExpr :: WithPos Expr }
          deriving (Show)

parse :: ByteString -> Either String Program
parse input = runAlex input parseInternal

parseError :: Token -> Alex a
parseError tok = do
  (AlexPn _ line col) <- getLexerPosn
  Alex $ \_ -> Left $ printf "%d:%d: Error handling token '%s'" line col (show tok)
}
