-- Parser -- Decaf parser                                       -*- haskell -*-
-- Copyright (C) 2013  Benjamin Barenblat <bbaren@mit.edu>
--
-- This file is a part of decafc.
--
-- decafc is free software: you can redistribute it and/or modify it under the
-- terms of the MIT (X11) License as described in the LICENSE file.
--
-- decafc is distributed in the hope that it will be useful, but WITHOUT ANY
-- WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
-- FOR A PARTICULAR PURPOSE.  See the X11 license for more details.
{
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedStrings #-}

module Parser ( parse
              , Program(..)
              , ImportDecl(..)
              , FieldDecl(..)
              , MethodDecl(..)
              , FieldElem(..)
              , Type(..)
              , Argument(..)
              , Block(..)
              , Statement(..)
              , Location(..)
              , AssignExpr(..)
              , MethodCall(..)
              , ImportArg(..)
              , CounterUpdate(..)
              , Expr(..)
              ) where

import Scanner ( Token(..)
               , Alex(..)
               , runAlex
               , alexMonadScan
               , getLexerRange
               )

import SourceLoc as SL

import Text.Printf (printf)
import Data.Text (Text)
import Data.ByteString.Lazy (ByteString)
}

--------------------------------- Directives ----------------------------------

%name parseInternal
%error { parseError }
%monad { Alex }
%lexer { lexerwrap } { EOF }
%tokentype { Token }

{-
Methods generated by Happy

parseInternal :: Alex Program
parseError :: Token -> Alex a
-}

%token
  id                { Identifier $$ }

  intLiteral        { IntLiteral $$ }
  stringLiteral     { StringLiteral $$ }
  boolLiteral       { BooleanLiteral $$ }
  charLiteral       { CharLiteral $$ }

  '{'               { LCurly }
  '}'               { RCurly }
  '['               { LBrack }
  ']'               { RBrack }
  '('               { LParen }
  ')'               { RParen }
  ';'               { Semicolon }
  '\:'              { Colon }
  ','               { Comma }
  '!'               { Negate }
  '?'               { Choice }

  import            { Keyword "import" }
  int               { Keyword "int" }
  bool              { Keyword "bool" }
  void              { Keyword "void" }
  if                { Keyword "if" }
  else              { Keyword "else" }
  for               { Keyword "for" }
  while             { Keyword "while" }
  return            { Keyword "return" }
  break             { Keyword "break" }
  continue          { Keyword "continue" }
  len               { Keyword "len" }

  '='               { AssignOp }
  '+'               { ArithmeticOp "+" }
  '-'               { ArithmeticOp "-" }
  '*'               { ArithmeticOp "*" }
  '/'               { ArithmeticOp "/" }
  '%'               { ArithmeticOp "%" }
  '<'               { RelationOp "<" }
  '<='              { RelationOp "<=" }
  '>'               { RelationOp ">" }
  '>='              { RelationOp ">=" }
  '=='              { EquationOp "==" }
  '!='              { EquationOp "!=" }
  '&&'              { ConditionOp "&&" }
  '||'              { ConditionOp "||" }
  incrementOp       { IncrementOp $$ }
  compoundAssignOp  { CompoundAssignOp $$ }


-- precedence --
%left '||'
%left '&&'
%nonassoc '==' '!='
%nonassoc '<' '<=' '>' '>='
%left '+' '-'
%left '*' '/' '%'
%left '!'
%left NEG

%% -------------------------------- Grammar -----------------------------------

Program : ImportDecls FieldDecls MethodDecls                { Program (reverse $1) (reverse $2) $3 }

ImportDecls : {- empty -}                                   { [] }
            | ImportDecls ImportDecl                        { $2 : $1 }
ImportDecl : import id ';'                                  {% insertRange$ ImportDecl $2 }

FieldDecls : {- empty -}                                    { [] }
           | FieldDecls FieldDecl                           { $2 : $1 }
FieldDecl : int FieldList ';'                               {% insertRange $ FieldDecl IntType (reverse $2) }
          | bool FieldList ';'                              {% insertRange $ FieldDecl BoolType (reverse $2) }

FieldList : FieldElem                                       { [$1] }
          | FieldList ',' FieldElem                         { $3 : $1 }
FieldElem : id                                              {% insertRange $ ScalarField $1 }
          | id '[' intLiteral ']'                           {% insertRange $ VectorField $1 $3 }

MethodDecls : {- empty -}                                   { [] }
            | MethodDecl MethodDecls                        { $1 : $2 }
MethodDecl : int id '(' ArgumentList ')' Block              {% insertRange $ MethodDecl $2 (Just IntType) (reverse $4) $6 }
           | bool id '(' ArgumentList ')' Block             {% insertRange $ MethodDecl $2 (Just BoolType) (reverse $4) $6 }
           | void id '(' ArgumentList ')' Block             {% insertRange $ MethodDecl $2 Nothing (reverse $4) $6 }
           | int id '(' ')' Block                           {% insertRange $ MethodDecl $2 (Just IntType) [] $5 }
           | bool id '(' ')' Block                          {% insertRange $ MethodDecl $2 (Just BoolType) [] $5 }
           | void id '(' ')' Block                          {% insertRange $ MethodDecl $2 Nothing [] $5 }

ArgumentList : Argument                                     { [$1] }
             | ArgumentList ',' Argument                    { $3 : $1 }
Argument : int id                                           {% insertRange $ Argument $2 IntType }
         | bool id                                          {% insertRange $ Argument $2 BoolType }

Block : '{' FieldDecls Statements '}'                       { Block $2 (reverse $3) }

Statements : {- empty -}                                    { [] }
           | Statements Statement                           { $2 : $1 }

Statement : Location AssignExpr ';'                         {% insertRange $ AssignStatement $1 $2 }
          | MethodCall ';'                                  {% insertRange $ MethodCallStatement $1 }
          | if '(' Expr ')' Block                           {% insertRange $ IfStatement $3 $5 }
          | if '(' Expr ')' Block else Block                {% insertRange $ IfElseStatement $3 $5 $7 }
          | for '(' id '=' Expr ';' Expr ';' CounterUpdate ')' Block    {% insertRange $ ForStatement $3 $5 $7 $9 $11 }
          | while '(' Expr ')' Block                        {% insertRange $ WhileStatement $3 $5 }
          | return ';'                                      {% insertRange $ ReturnVoidStatement }
          | return Expr ';'                                 {% insertRange $ ReturnExprStatement $2 }
          | break ';'                                       {% insertRange $ BreakStatement }
          | continue ';'                                    {% insertRange $ ContinueStatement }

CounterUpdate : Location AssignExpr                         { CounterUpdate $1 $2 }

Location : id                                               { ScalarLocation $1 }
         | id '[' Expr ']'                                  { VectorLocation $1 $3 }

AssignExpr : AssignOp Expr                                  { AssignExpr $1 $2 }
           | incrementOp                                    { IncrementExpr $1 }

AssignOp : '='                                              { "=" }
         | compoundAssignOp                                 { $1 }

MethodCall : id '(' ImportArgs ')'                          { MethodCall $1 (reverse $3) }
           | id '(' ')'                                     { MethodCall $1 [] }

ImportArgs : ImportArg                                      {[$1] }
           | ImportArgs ',' ImportArg                       { $3 : $1 }

ImportArg : Expr                                            {% insertRange $ ExprImportArg $1 }
          | stringLiteral                                   {% insertRange $ StringImportArg $1 }

Expr : Expr1                                                { $1 }
     | Expr1 '?' Expr1 '\:' Expr                            {% insertRange $ ChoiceExpr $1 $3 $5 }

Expr1 : Location                                            {% insertRange $ LocationExpr $1 }
      | MethodCall                                          {% insertRange $ MethodCallExpr $1 }
      | intLiteral                                          {% insertRange $ IntLiteralExpr $1 }
      | charLiteral                                         {% insertRange $ CharLiteralExpr $1 }
      | boolLiteral                                         {% insertRange $ BoolLiteralExpr $1 }
      | len '(' id ')'                                      {% insertRange $ LenExpr $3 }
      | Expr1 '+' Expr1                                     {% insertRange $ ArithOpExpr "+" $1 $3 }
      | Expr1 '-' Expr1                                     {% insertRange $ ArithOpExpr "-" $1 $3 }
      | Expr1 '*' Expr1                                     {% insertRange $ ArithOpExpr "*" $1 $3 }
      | Expr1 '/' Expr1                                     {% insertRange $ ArithOpExpr "/" $1 $3 }
      | Expr1 '%' Expr1                                     {% insertRange $ ArithOpExpr "%" $1 $3 }
      | Expr1 '<' Expr1                                     {% insertRange $ RelOpExpr "<" $1 $3 }
      | Expr1 '<=' Expr1                                    {% insertRange $ RelOpExpr "<=" $1 $3 }
      | Expr1 '>' Expr1                                     {% insertRange $ RelOpExpr ">" $1 $3 }
      | Expr1 '>=' Expr1                                    {% insertRange $ RelOpExpr ">=" $1 $3 }
      | Expr1 '==' Expr1                                    {% insertRange $ EqOpExpr "==" $1 $3 }
      | Expr1 '!=' Expr1                                    {% insertRange $ EqOpExpr "!=" $1 $3 }
      | Expr1 '&&' Expr1                                    {% insertRange $ CondOpExpr "&&" $1 $3 }
      | Expr1 '||' Expr1                                    {% insertRange $ CondOpExpr "||" $1 $3 }
      | '-' Expr1 %prec NEG                                 {% insertRange $ NegativeExpr $2 }
      | '!' Expr1                                           {% insertRange $ NegateExpr $2 }
      | '(' Expr1 ')'                                       {% insertRange $ ParenExpr $2 }

----------------------------------- Haskell -----------------------------------
{

lexerwrap :: (Token -> Alex a) -> Alex a
lexerwrap s = do
  token <- alexMonadScan
  s token

insertRange :: a -> Alex (SL.Located a)
insertRange a = do
  range <- getLexerRange
  return $ SL.LocatedAt range a

withRange :: (SL.Range -> a) -> Alex a
withRange f = do
  range <- getLexerRange
  return $ f range

data Posn = Posn { row :: Int
                 , col :: Int
                 } deriving (Show, Eq, Ord)

data Program = Program { importDecls :: [SL.Located ImportDecl]
                       , fieldDecls :: [SL.Located FieldDecl]
                       , methodDecls :: [SL.Located MethodDecl]
                       } deriving (Show)

data ImportDecl = ImportDecl { importId :: Text }
                  deriving (Show)

data FieldDecl = FieldDecl { fieldType :: Type
                           , elems:: [SL.Located FieldElem]
                           } deriving (Show)

data FieldElem = ScalarField { fieldId :: Text }
               | VectorField { fieldId :: Text, size :: Text }
                 deriving (Show)

data Type = IntType | BoolType
            deriving (Show)

data MethodDecl = MethodDecl { methodId :: Text
                             , returnType :: Maybe Type
                             , arguments :: [SL.Located Argument]
                             , block :: Block
                             } deriving (Show)

data Argument = Argument { argumentId :: Text
                         , argumentType :: Type
                         } deriving (Show)

data Block = Block { blockFieldDecls :: [SL.Located FieldDecl]
                   , blockStatements :: [SL.Located Statement]
                   } deriving (Show)

data Statement = AssignStatement { assignLocation :: Location, assignExpr :: AssignExpr }
               | MethodCallStatement { methodCallStatement :: MethodCall }
               | IfStatement { ifExpr :: SL.Located Expr, ifBlock :: Block }
               | IfElseStatement { ifExpr :: SL.Located Expr, ifBlock :: Block, elseBlock :: Block}
               | ForStatement { counterId :: Text, counterExpr :: SL.Located Expr, forPredExpr :: SL.Located Expr,
                                counterUpdate :: CounterUpdate, forBlock :: Block }
               | WhileStatement { whileExpr :: SL.Located Expr, whileBlock :: Block }
               | ReturnVoidStatement
               | ReturnExprStatement { returnExpr :: SL.Located Expr }
               | BreakStatement
               | ContinueStatement
               | ErrorStatement
                 deriving (Show)

data Location = ScalarLocation { locationId :: Text }
              | VectorLocation { locationId :: Text, arrayIndexExpr :: SL.Located Expr }
                deriving (Show)

data AssignExpr = AssignExpr { assignOp :: Text, assignSourceExpr:: SL.Located Expr }
                | IncrementExpr { incrementOp :: Text }
                  deriving (Show)

data MethodCall = MethodCall { methodName :: Text, importArguments :: [SL.Located ImportArg] }
                  deriving (Show)

data ImportArg = ExprImportArg { argumentExpr :: SL.Located Expr }
               | StringImportArg { argumentString :: Text }
                 deriving (Show)

data CounterUpdate = CounterUpdate { counterLocation :: Location, updateExpr :: AssignExpr }
                     deriving (Show)

data Expr = LocationExpr { location :: Location }
          | MethodCallExpr { methodCallExpr :: MethodCall }
          | IntLiteralExpr { intLiteral :: Text }
          | CharLiteralExpr { charLiteral :: Text }
          | BoolLiteralExpr { boolLiteral :: Text }
          | LenExpr { lenId :: Text }
          | ArithOpExpr { arithOp :: Text, lExpr :: SL.Located Expr, rExpr :: SL.Located Expr }
          | RelOpExpr { relOp :: Text, lExpr :: SL.Located Expr, rExpr :: SL.Located Expr }
          | EqOpExpr { eqOp :: Text, lExpr :: SL.Located Expr, rExpr :: SL.Located Expr }
          | CondOpExpr { condOp :: Text, lExpr :: SL.Located Expr, rExpr :: SL.Located Expr }
          | NegativeExpr { negativeExpr :: SL.Located Expr }
          | NegateExpr { negateExpr :: SL.Located Expr }
          | ParenExpr { parenExpr :: SL.Located Expr }
          | ChoiceExpr { choicePredExpr :: SL.Located Expr, lExpr :: SL.Located Expr, rExpr :: SL.Located Expr }
          deriving (Show)

parse :: ByteString -> Either String Program
parse input = runAlex input parseInternal

parseError :: Token -> Alex a
parseError tok = do
  (SL.Range (SL.Posn _ line col) _) <- getLexerRange
  Alex $ \_ -> Left $ printf "%d:%d: Error handling token '%s'" line col (show tok)
}
